

//linea de prueba


int[] prefixSums(int[] a) {
	    int[] b = new int[a.Length];
            b[0] = a[0];
            for (int i = 1; i < a.Length; i++)
            {
                b[i] = a[i] + b[i - 1];
            }
            return b;
}



boolean regularBracketSequence2(String sequence) {

  LinkedList<Character> stack = new LinkedList<>();
  for (int i = 0; i < sequence.length(); i++) {
    if (stack.size() > 0
        && stack.getLast() == '(' && sequence.charAt(i) == ')') {
      stack.pollLast();
      continue;
    }
    if (stack.size() > 0
        && stack.getLast() == '[' && sequence.charAt(i) == ']') {
      stack.pollLast();
      continue;
    }
    stack.addLast(sequence.charAt(i));
  }

  if (stack.size() != 0) {
    return false;
  }
  return true;
}


string properNounCorrection(string noun) {
return char.ToUpper(noun[0]) + noun.Substring(1).ToLower();
}



  static int maxZeros(int n)
        {
            int max_z = 0;
            int max_base = -1;
            for (int b = 2; b <= 10; b++)
            {
                int zeros = 0;
                int c = n;
                while (c > 0)
                {
                    if (c % b == 0)
                    {
                        zeros++;
                    }
                    c /= b;
                }
                //max_z = Math.Max(max_z, zeros);
                if (zeros > max_z)
                {
                    max_base = b;
                    max_z = zeros;
                    //Console.WriteLine(b + " " + zeros);
                }
            }
            return max_base;
        }


int josephusProblem(int n, int k) {

  boolean[] removed = new boolean[n];
  int currentPerson = 0;

  for (int i = 1; i < n; i++) {
    int skipped = 0;
    while (skipped < k - 1) {
      if (!removed[currentPerson]) {
        skipped++;
      }
      currentPerson = (currentPerson + 1) % n;
    }
    while (removed[currentPerson]) {
      currentPerson = (currentPerson + 1) % n;
    }
    removed[currentPerson] = true;
  }

  for (int i = 0; i < n; i++) {
    if (!removed[i]) {
      return i + 1;
    }
  }
  return 0;
}

typedef std::vector<std::vector<int>> Matrix;

Matrix constructSubmatrix(Matrix matrix,
                          std::vector<int> rowsToDelete,
                          std::vector<int> columnsToDelete) {

  std::vector<int> line((int)matrix[0].size() - (int)columnsToDelete.size());
  Matrix res((int)matrix.size() - (int)rowsToDelete.size(), line);
  std::vector<bool> useRow(matrix.size(), true);
  std::vector<bool> useColumn(matrix[0].size(), true);

  for (int i = 0; i < rowsToDelete.size(); i++) {
    useRow[rowsToDelete[i]] = false;
  }
  for (int i = 0; i < columnsToDelete.size(); i++) {
    useColumn[columnsToDelete[i]] = false;
  }

  for (int i = 0, i2 = 0; i < matrix.size(); i++) {
    if (useRow[i]) {
      for (int j = 0, j2 = 0; j < matrix[0].size(); j++) {
        if (useColumn[j]) {
          res[i2][j2++] = matrix[i][j];
        }
      }
      i2++;
    }
  }

  return res;
}




 int[] zFunctionNaive(string s)
        {
            int[] r = new int[s.Length];
            for (int i = 0; i < s.Length; i++)
            {
                int j = 0;
                while (i + j < s.Length && s[i + j] == s[j])
                {
                    j++;
                }
                r[i] = anz;
            }
            return r;
        }

int avoidObstacles(int[] inputArray) {

  for (int i = 1; ; i++) {
    for (int j = 0; j < inputArray.length; j++) {
      if (inputArray[j] % i == 0) {
        break;
      }
      if (j == inputArray.length-1) {
        return i;
      }
    }
  }
}


int[] mixedFractionToImproper(int[] a) {
    int[] b=new int[2];
    b[0]=a[0]*a[2]+a[1];
    b[1]=a[2];
    return b;
}


int mySqrt(int n) {

  int left = 1, right = n + 1;
  while (left + 1 < right) {
    int middle = left + 1;
    if (middle * middle <= n) {
      left = middle;
    }
    else {
      right = middle;
    }
  }

  return left;
}

int arrayMaximalAdjacentDifference(int[] inputArray) {
int max =0;
            for (int i = 0; i + 1< inputArray.Length; i++)
            {
                max = Math.Max(Math.Abs(inputArray[i] - inputArray[i + 1]), max);
            }
            return max;
}

bool isOneSwapEnough(string inputString) {
   char[] ch = inputString.ToCharArray();

            char[] rev = new char[ch.Length];
            Array.Copy(ch, rev, ch.Length);
            Array.Reverse(rev);

            if (new string(ch) == new string(rev))
            {
                return true;
            }

            for (int i = 0; i < ch.Length - 1; i++)
            {
                for (int j = i + 1; j < ch.Length; j++)
                {
                    char temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;

                    rev = new char[ch.Length];
                    Array.Copy(ch, rev, ch.Length);
                    Array.Reverse(rev);

                    if (new string(ch) ==  new  string( rev))
                    {
                        return true;
                    }
                    temp = ch[j];
                    ch[j] = ch[i];
                    ch[i] = temp;
                }
            }

            return false;
}





bool increaseNumberRoundness(int n) {

  bool gotToSignificant = false;
  while (n > 0) {
    if (n % 10 == 0 && gotToSignificant) {
      return true;
    } else if (n % 10 != 0) {
      gotToSignificant = true;
    }
    n /= 10;
  }

  return false;
}


std::string whoseMove(std::string lastPlayer, bool win) {
   if (win)
      return lastPlayer;
   if (lastPlayer=="white")
      return "black";
   return "white";
}


int rounders(int n) {
 string s = n + "";
            char[] ch = s.ToCharArray();
            int i = s.Length - 1;

            while (i > 0)
            {
                if (ch[i] < '5')
                {
                    ch[i] = '0';

                }
                if (ch[i] >= '5')
                {
                    if (i - 1 >= 0)
                    {
                        ch[i] = '0';
                        if (ch[i - 1] + 1 <= '9')
                        {
                            ch[i - 1]++;
                        }
                        else
                        {
                            ch[i - 1] = '0';
                            return int.Parse("1" + new string(ch));
                        }
                    }
                    
                }
                i--;
            }

            return int.Parse(new string(ch));
}




static int[] arrayPreviousLess(int[] items)
        {
            int[] ans = new int[items.Length];
            for (int i = 0; i < items.Length; i++)
            {
                int j;
                for ( j = i - 1; j >= 0; j--)
                {
                    if (items[j] < items[i])
                    {
                        ans[i] = items[j];
                        break;
                    }
                }
                if (j == -1)
                {
                    ans[i] = -1;
                }
            }

            return ans;
        }

int axisAlignedCirclesBoundingBox(int[] x, int[] y, int[] r) {
int minX = x[0] - r[0],
                maxX = x[0] + r[0],
                minY = y[0] - r[0],
                maxY = y[0] + r[0];

            for (int i = 1; i < x.Length; i++)
            {
                minX = Math.Min(x[i] - r[i], minX);
                maxX = Math.Max(x[i] + r[i], maxX);
                minY = Math.Min(y[i] - r[i], minY);
                maxY = Math.Max(y[i] + r[i], maxY);
            }

            return (maxX - minX) * (maxY - minY);
}

 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        }

          int[] fractionMultiplication(int[] a, int[] b)
        {
            int num = a[0] * b[0];
            int den = a[1] * b[1];

            int g = gcd(num, den);
            return new int[] { num / g, den / g };

        }


bool coolString(string s) {
 
             if (s.Length == 1 && char.IsLetter(s[0])) return true;


            s = s.Replace(" ", "").Trim();

            bool contiene_letra = false;

            for (int i = 0; i + 1 < s.Length; i++)
            {
                if (char.IsLetter(s[i]) && char.IsLetter(s[i + 1]))
                {
                    if (char.IsLower(s[i]) && char.IsLower(s[i + 1]))
                    {
                        return false;
                    }
                    if (char.IsUpper(s[i]) && char.IsUpper(s[i + 1]))
                    {
                        return false;
                    }
                    contiene_letra = true;
                }
                else
                {
                    return false;
                }
            }

            if (!contiene_letra) return false;

            return true;

}



bool sameDigitNumber(int n) {
string s = n+"";
            char actual = s[0];

            for (int i = 1; i < s.Length; i++)
            {
                if (s[i] != actual) return false;
            }
            return true;
}




function reversedSumOfDigits(p, n) {
    if (!p && 1 === n) return '0';
    if (9 * n < p || !p) return '-1';

    const result = [];
    for (let i = 0; n - 1 > i; ++i) {
        const a = 9 < (p - 1) ? 9 : (p - 1);
        p -= a;
        result.unshift(a);
    }
    return p + result.join('');
}


 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        } 
         int eulersTotientFunction(int n)
        {
            int ans = 0;
            for (int i = 1; i <= n; i++)
            {
                if (gcd(i, n) == 1)
                {
                    ans++;
                }
            }
            return ans;
        }



String mySubstring(String i, int l, int r) {
    return i.substring(l,r+1);
}


int candies(int n, int m) {
    int eat = m % n;
    return m-eat;
}

int polygonPerimeter(bool[][] matrix) {
int p = 0;
            for (int i = 0; i  < matrix.Length; i++)
            {
                for (int j = 0; j  < matrix[i].Length; j++)
                {
                    if (j+1 < matrix[i].Length && matrix[i][j] != matrix[i][j + 1])
                    {
                        p++;
                    }
                    if ( i+1 < matrix.Length && matrix[i][j] != matrix[i + 1][j])
                    {
                        p++;
                    }
                    if (matrix[i][j]) //bordes
                    {
                        if (i - 1 < 0) p++;
                        if (i + 1 >= matrix.Length) p++;
                        if (j - 1 < 0) p++;
                        if (j + 1 >= matrix[i].Length) p++;
                    }
                }
            }
            return p;
}



int findSquareSide(int[] x, int[] y) {
        class Helper {
            int sqr(int x) {
                return x * x;
            }

            int squareDistance(int[] a, int[] b) {
                return sqr(a[0] - b[0]) + sqr(a[1] - b[1]);
            }

            int[] point(int x, int y) {
                return new int[]{x, y};
            }
        }
        Helper h = new Helper();

        int answer = h.squareDistance(h.point(x[0], y[0]), h.point(x[1], y[1]));
        for (int i = 2; i < 4; i++) {
            answer = Math.min(answer,
                    h.squareDistance(h.point(x[i - 1], y[i - 1]),
                            h.point(x[i], y[i])));
        }
        return answer;
}


int[] inversePermutation(int[] permutation) {
           int[] ans = new int[permutation.Length];

            for (int i = 0; i < permutation.Length; i++)
            {
                ans[permutation[i]-1] = i+1;
            }
            return ans;
}


function parabole(a, b, c, x) {
    return a * x ** 2 + b * x + c
}

bool reverseToSort(int[] inputArray) {
	    for (int i = 0; i < inputArray.Length - 1; i++)
            {
                for (int j = i + 1; j < inputArray.Length; j++)
                {
                    int k = i, l = j;

                    while (k < l)
                    {
                        int temp = inputArray[k];
                        inputArray[k] = inputArray[l];
                        inputArray[l] = temp;
                        k++;
                        l--;
                    }
                    bool ordenado = true;
                    for (int m = 0; m + 1< inputArray.Length; m++)
                    {
                        //Console.Write(inputArray[m] + " ");
                        if (inputArray[m + 1] <= inputArray[m])
                        {
                            ordenado = false;
                            break;
                        }
                    }

                    if (ordenado) return true;

                    //Console.WriteLine();
                    k = i; l = j;

                    while (k < l)
                    {
                        int temp = inputArray[k];
                        inputArray[k] = inputArray[l];
                        inputArray[l] = temp;
                        k++;
                        l--;
                    }
                }
                
            }

            return false;
}


int absoluteValuesSumMinimization(int[] a) {

  int indexOfMinimum = -1;
  int minimalSum = Integer.MAX_VALUE;

  for (int i = 0; i < a.length; i++) {
    int sum = 0;
    for (int j = 0; j < a.length; j++) {
      sum += Math.abs(a[j] - a[i]);
    }
    if (sum < minimalSum) {
      indexOfMinimum = i;minimalSum=sum;
    }
  }

  return a[indexOfMinimum];
}



int[] threeAndFour(int n) {
    
    List<int> arr = new List<int>();
    for(int i =0; i<=n; i++) {
        
        if(i%3 ==0 && i%4 ==0) {
            arr.Add(i);   
        }
    }
    return arr.ToArray();
}


void mergeArrays(std::vector<int> &sequence, int left, int middle, int right) {
  std::vector<int> result;
  int i, j;

  for (i = left, j = middle; i < middle && j < right; ) {
    if (sequence[i] < sequence[j]) {
      result.push_back(sequence[i]);
      i++;
    }
    else {
      result.push_back(sequence[j]);
      j++;
    }
  }

  while (i < middle) {
    result.push_back(sequence[i]);
    i++;
  }

  while (j < right) {
    result.push_back(sequence[j]);
    j++;
  }

  for (i = left; i < right; i++) {
    sequence[i] = result[i - left];
  }
}

void split(std::vector<int> &sequence, int left, int right) {
  if (left + 1 == right) {
    return;
  }
  int middle = (left + right) / 2;
  split(sequence, left, middle);
  split(sequence, middle, right);
  mergeArrays(sequence, left, middle, right);
}

std::vector<int> mergeSort(std::vector<int> sequence) {

  split(sequence, 0, sequence.size());

  return sequence;
}


------------------------------------

string addDigits(long a, long b, int n) {
	    int k = 0;
            while (true)
            {
                for (long i = 9; i >= 0; i--)
                {
                    if ((a * 10 + i) % b == 0)
                    {
                        if (k == n) { return a.ToString(); }
                        a = a * 10 + i;
                        k++;
                        break;
                    }
                }
                if (a % b != 0) break;
            }

            return a.ToString();
}



int sumprimeFactors(int n)
        {
            //List<int> p = new List<int>();
            int p = 0;
            // Print the number of 2s that divide n 
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                //p.Add(2);
                p += 2;
                n /= 2;
            }

            // n must be odd at this point. So we can 
            // skip one element (Note i = i +2) 
            for (int i = 3; i <= Math.Sqrt(n); i += 2)
            {
                // While i divides n, print i and divide n 
                while (n % i == 0)
                {
                    //Console.Write(i + " ");
                    //p.Add(i);
                    p += i;
                    n /= i;
                }
            }

            // This condition is to handle the case whien 
            // n is a prime number greater than 2 
            if (n > 2)
            {
                //p.Add(n);
                p += n;
            }
            //Console.Write(n);

            return p;
        }

         int factorSum(int n)
        {
            
            HashSet<int> hash = new HashSet<int>();
            
            while (true)
            {
                n = sumprimeFactors(n);
                
                if (!hash.Add(n)) break ;
               
            }
            return n;
        }



----------------------------------

string longestDigitsPrefix(string inputString) {
string pre = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                if (inputString[i] >= '0' && inputString[i] <= '9')
                {
                    pre += inputString[i];
                }
                else
                {
                    break;
                }

            }
            return pre;
}


std::vector<int> eratosthenesSieve(int n) {

  std::vector<int> primes;
  std::vector<bool> mayBePrime(n + 1, true);

  for (int i = 2; i <= n; i++) {
    if (mayBePrime[i]) {
      primes.push_back(i);
      for (int j = i; i * j <= n; j++) {
        mayBePrime[i * j] = false;
      }
    }
  }

  std::vector<int> result;
  for (int i = 0; i < primes.size(); i++) {
    result.push_back(primes[i]);
  }

  return result;
}

bool higherVersion(string ver1, string ver2) {
    string[] s1 = ver1.Split('.');
    string[] s2 = ver2.Split('.');
    for(int i=0;i<Math.Min(s1.Length,s2.Length);i++) {
        if(int.Parse(s1[i])>int.Parse(s2[i]))
            return true;
        else if(int.Parse(s1[i])<int.Parse(s2[i]))
            return false;
    }
    return false;
}

int niceFractions2(int n) {
  int res = 0;
  for (int i = 0; i*n < int(1e5); i++) {
    bool digits[10] = {};
    int a = i * n;
    int b = i;
    bool isNice = true;
    for (int j = 0; j < 5; j++) {
      digits[a % 10] = true;
      a /= 10;
      digits[b % 10] = true;
      b /= 10;
    }
    for (int j = 0; j < 10; j++) {
      if (!digits[j]) {
        isNice = false;
        break;
      }
    }
    if (isNice) {
      res++;
    }
  }
  return res;
}


int combs(string comb1, string comb2) {
	    string c1 = comb1;
            string c2 = comb2;

            if (c2.Length <= c1.Length)
            {
                c1 = comb2;
                c2 = comb1;
            }
            int izq = 0, der = comb1.Length + comb2.Length;

            int minLen = comb1.Length + comb2.Length;

            while (der >= 0)
            {
                string cerosIzqC1 = new string('0', comb2.Length);
                string cerosDerC1 = new string('0', comb2.Length);
                c1 = cerosIzqC1 + comb1 + cerosDerC1;

                string cerosIzq = new string('0', izq);
                string cerosDer = new string('0', der);

                c2 = cerosIzq + comb2 + cerosDer;
                Console.WriteLine(c1);
                Console.WriteLine(c2);
                Console.WriteLine();

                bool encajanTodos = true;

                for (int i = 0; i < c1.Length; i++)
                {
                    if (c1[i] != '0' && c2[i] != '0')
                    {
                        if (c1[i] == '*' && c2[i] == '*')
                        {
                            encajanTodos = false;
                            break;
                        }
                    }
                }

                if (encajanTodos)
                {
                    //int primerAsteriscoC2 = c2.IndexOf('*');
                    //int ultimoAsteriscoC1 = c1.LastIndexOf('*');

                    int primerC1 = c1.IndexOf('*');
                    int primerC2 = c2.IndexOf('*');

                    int ultimoC1 = c1.LastIndexOf('*');
                    int ultimoC2 = c2.LastIndexOf('*');

                    minLen = Math.Min(minLen, Math.Max(ultimoC1, ultimoC2)- Math.Min(primerC1, primerC2)+1);


                }

                Console.WriteLine("Min len: " + minLen);

                der--;
                izq++;
            }

            return minLen;
}



int dfsComponentSize(boolean[][] matrix, int vertex) {
class Helper {
            int componentSize = 0;

            void dfs(int currentVertex, ArrayList<Boolean> visited) {
                visited.set(currentVertex, true);
                componentSize++;
                for (int nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
                    if (matrix[currentVertex][nextVertex] && !visited.get(nextVertex)) {
                        dfs(nextVertex, visited);
                    }
                }
            }
        }
        Helper h = new Helper();

        ArrayList<Boolean> visited = new ArrayList<>();

        for (int i = 0; i < matrix.length; i++) {
            visited.add(false);
        }

        h.dfs(vertex, visited);

        return h.componentSize;
}


bool validTime(std::string Time) {

  struct Helper {
    int charToInt(char symbol) {
      return int(symbol) - int('0');
    }
  };

  Helper h;

  int hours = h.charToInt(Time[0]) * 10 + h.charToInt(Time[1]),
      minutes = h.charToInt(Time[3]) * 10 + h.charToInt(Time[4]);

  if (hours < 24 && minutes < 60) {
    return true;
  }
  return false;
}


int arrayMinimumIndex(int[] inputArray) {
int ind = -1, min = int.MaxValue;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] < min)
                {
                    min = inputArray[i];
                    ind = i;
                }
            }
            return ind;
}

bool isEarlier(int[] time1, int[] time2) {
  return  time1[0] < time2[0] || (time1[0] == time2[0]&& time1[1]<time2[1] )  ;
}

bool isEarlier(std::vector<int> time1, std::vector<int> time2) {
  if (time1[0] < time2[0] || (time1[0] == time2[0]&& time1[1]<time2[1] )) {
    return true;
  }
  return false;
}

bool charactersRearrangement(string string1, string string2) {
  char[] ch1 = string1.ToCharArray();
            Array.Sort(ch1);

            char[] ch2 = string2.ToCharArray();
            Array.Sort(ch2);

            return new string(ch1) == new string(ch2);
}



function seatsInTheater(nCols, nRows, col, row) {
  return (nCols-col+1) * (nRows-row)
}

int arrayMinimumAboveBound(int[] inputArray, int bound) {
	    int dif = int.MaxValue;
            int min_dif = int.MaxValue;
            int ans = -51;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > bound)
                {
                    dif = inputArray[i] - bound;
                    if (dif < min_dif)
                    {
                        min_dif = dif;
                        ans = inputArray[i];
                    }
                }
            }
            return ans;
}


bool checkFactorial(int n) {
    int prod = 1;
            for (int i = 1; ; i++)
            {
                prod *= i;
                if (prod == n) return true;
                if (prod > n) break;
            }
            return false;
}

int[] extractMatrixColumn(int[][] matrix, int column) {
 List<int> ans = new List<int>();
            for (int i = 0; i < matrix.Length; i++)
            {
                ans.Add(matrix[i][column]);
            }
            return ans.ToArray();
}

string strangeCode(int s, int e) {
 	    string res = "";
            char last = 'b';
            while (s < e - 1)
            {
                s++;
                e--;
                if (last == 'a')
                {
                    res += 'b';
                    last = 'b';
                }
                else
                {
                    res += 'a';
                    last = 'a';
                }
            }
            return res;
}


int[] directionOfReading(int[] numbers) {
 int max_len = numbers.Length;
            //for (int i = 0; i < numbers.Length; i++)
            //{
            //    max_len = Math.Max(max_len, numbers[i].ToString().Length);
            //}

            List<string> lista = new List<string>();
            for (int i = 0; i < numbers.Length; i++)
            {
                lista.Add(new string('0', max_len - numbers[i].ToString().Length) + numbers[i].ToString()); 
            }

            //foreach (string item in lista)
            //{
            //    Console.WriteLine(item);
            //}
            //return new int[0];

            List<int> ans = new List<int>();
            for (int j = 0; j < lista[0].Length; j++)
            {
                string item = "";
                for (int i = 0; i < lista.Count; i++)
                {
                    item += lista[i][j] + "";
                }
                ans.Add(int.Parse(item));
            }

            return ans.ToArray();
}



boolean pairOfShoes(int[][] shoes) {
  ArrayList<Integer> leftShoes = new ArrayList<>();
  ArrayList<Integer> rightShoes = new ArrayList<>();
  for (int i = 0; i < shoes.length; i++) {
    if (shoes[i][0] == 0) {
      leftShoes.add(shoes[i][1]);
    } else {
      rightShoes.add(shoes[i][1]);
    }
  }
  Collections.sort(leftShoes);
  Collections.sort(rightShoes);
  if (leftShoes.size() != rightShoes.size()) {
    return false;
  }
  for (int i = 0; i < leftShoes.size(); i++) {
    if (leftShoes.get(i)  != rightShoes.get(i)) {
      return false;
    }
  }
  return true;
}



int permutationShift(int[] permutation) {
int[] ans = new int[permutation.Length];
            int k =0;
            for (int i = 0; i < permutation.Length; i++)
            {
                ans[k++] = permutation[i] - i;
            }
            return ans.Max() - ans.Min();
}


 int halvingSum(int n)
        {
            int sum = 0;
            while (n >= 1)
            {
                sum += n;
                n /= 2;
            }
            return sum;
        }


int arrayMode(int[] sequence) {
  Dictionary<int, int> dic = new Dictionary<int, int>();
            int moda = -1;
            int max_frec = 0;
            foreach (int item in sequence)
            {
                if (dic.ContainsKey(item))
                {
                    dic[item]++;
                }
                else
                {
                    dic[item] = 1;
                }
                if (dic[item] > max_frec)
                {
                    max_frec = dic[item];
                    moda = item;
                }

            }
            return moda;
}


int[] alternatingSums(int[] a) {
 int x = 0, y = 0;
            for (int i = 0; i < a.Length; i++)
            {
                if (i % 2 == 0)
                {
                    x += a[i];
                }
                else
                {
                    y += a[i];
                }
            }
            return new int[] { x, y };
}

int summaryProficiency(int[] a, int n, int m) {
 
            int sum = 0;
            int cont = 0;
            for (int i = 0; i < a.Length  ; i++)
            {
                if (a[i] >= m)
                {
                    sum += a[i];
                    cont++;
                    if (cont == n) break;
                }
            }
            return sum;
}


int adjacentElementsProduct(int[] inputArray) {
int ans = int.MinValue;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                ans = Math.Max(ans, inputArray[i] * inputArray[i + 1]);
            }
            return ans;
}

 string longestString(string[] inputArray)
        {
            string lon = inputArray[0];
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i].Length > lon.Length)
                {
                    lon = inputArray[i];
                }
            }
            return lon;
        }

int zigzag(int[] a) {

  int best = 1;
  int left = 0;
  while (left < a.length) {
    int right = left + 1;
    while (right < a.length) {
      if (right == left + 1) {
        if (a[left] == a[right]) {
          break;
        }
      } else {
        if ((a[right - 1] - a[right - 2]) * (a[right - 1] - a[right]) <= 0) {
          break;
        }
      }
      right++;
    }
    best = Math.max(best, right - left);
    left = right;
    if (left < a.length && a[left - 1] != a[left]) {
      left--;
    }
  }

  return best;
}



int sumOfPowers(int n, int divisor) {
	int sum = 0;
            for (int i = 1; i <= n; i++)
            {

                for (int p = n; p >= 0; p--)
                {
                    if (i % (int) Math.Pow(divisor, p) == 0)
                    {
                        sum += p;
                        break;
                    }

                }

            }

            return sum;
}


int differentValues(int[] a, int d) {

  int best = -1;
  for (int i = 0; i < a.length; i++) {
    for (int j = i + 1; j < a.length; j++) {
      int diff = Math.abs(a[j] - a[i]);
      if (diff > d && (diff < best || best == -1)) {
        best = diff;
      }
    }
  }

  return best;
}


int minimalMultiple(int divisor, int lowerBound) {
	return (int)Math.Ceiling( (double) lowerBound / (double) divisor) * divisor;
}

boolean reachNextLevel(int experience, int threshold, int reward) {
    
    return experience+reward >= threshold;

}


bool rightTriangle(int[] sides) {
    Array.Sort(sides);

            return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];
}



int sequenceElement(std::vector<int> a, int n) {

  const int MOD = (int)1e5;
  std::vector<int> seq;
  for (int i = 0; i < 5; i++) {
    seq.push_back(a[i]);
  }

  int lastFive = a[0] * (int)1e4 + a[1] * (int)1e3 +
                 +a[2] * (int)1e2 + a[3] * (int)1e1 +
                  a[4] * (int ) 1e0;
  std::map<int, int> was;
  was[lastFive] = 4;

  for (int i = 5;; i++) {
    seq.push_back((seq[i - 1] + seq[i - 2] +
              seq[i - 3] + seq[i - 4] + seq[i - 5]) % 10);
    lastFive = (lastFive * 10 + seq[i]) % MOD;
    if (was.find(lastFive) != was.end()) {
      int last = was[lastFive];
      return seq[n % (i - last)];
    } else {
      was[lastFive] = i;
    }
  }
}

string[] binaryGenerator(string s) {
	   HashSet<string> a = new HashSet<string>();
            a.Add("");

            foreach(char ch in s)
            {
                HashSet<string> b = new HashSet<string>();
                foreach(string  c in a)
                {
                    b.Add(c + "1");
                    if (ch == '0') b.Add(c + "0");
                }
                a = b;
            }
            List<string> r = a.ToList();
            r.Sort();
            return r.ToArray();
}

int countIncreasingSequences(int n, int k) {

  /*
   * vector dp (short for dynamic programming)
   * is used for storing the interim values.
   */
  std::vector<int> line(k + 1, 0);
  std::vector<std::vector<int>> dp(n + 1, line);
  dp[0][0] = 1;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      for (int q = 0; q < j; q++) {
        dp[i][j] += dp[i - 1][q];
      }
    }
  }

  int sum = 0;
  for (int j = 1; j <= k; j++) {
    sum += dp[n][j];
  }

  return sum;
}



bool isPrime(int n) {
	   if (n < 2) return false;
            if (n == 2) return true;
            if (n % 2 == 0) return false;

            for (int i = 3; i * i <= n; i += 2)
            {
                if (n % i == 0) return false;
            }
            return true;
}

int differentSubstringsTrie(std::string inputString) {

  typedef std::vector<std::vector<int>> Array2D;

  struct Helper {
    Array2D addNode(Array2D lastVersion) {
      std::vector<int> line(26, 0);
      lastVersion.push_back(line);
      return lastVersion;
    }
  };

  Helper h;

  int nodesCount = 1;
  Array2D trie;
  trie = h.addNode(trie);

  for (int i = 0; i < inputString.size(); i++) {
    int currentNode = 0;
    for (int j = i; j < inputString.size(); j++) {
      int symbol = inputString[j] - 'a';
      if (!trie[currentNode][symbol]) {
        trie = h.addNode(trie);
        trie[currentNode][symbol] = nodesCount;
        nodesCount++;
      }
      currentNode = trie[currentNode][symbol];
    }
  }

  return nodesCount - 1;
}

int differentSubstringsTrie(string s) {
           HashSet<string> hash = new HashSet<string>();

            for (int i = 0; i < s.Length; i++)
            {
                for (int j = i; j < s.Length; j++)
                {
                    hash.Add(s.Substring(i, j - i + 1));
                }
            }

            return hash.Count;
}



boolean isTournament(int n, int[] fromV, int[] toV) {

  ArrayList<ArrayList<Boolean>> edges = new ArrayList<>();

  for (int i = 0; i < n; i++) {
    ArrayList<Boolean> line = new ArrayList<>();
    for (int j = 0; j < n; j++) {
      line.add(false);
    }
    edges.add(line);
  }

  for (int i = 0; i < fromV.length; i++) {
    edges.get( fromV[i] - 1 ).set( toV[i] - 1, true );
  }

  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      if (edges.get(i).get(j) == edges.get(j).get(i)) {
        return false;
      }
    }
  }

  if (fromV.length != n * (n - 1) / 2) {
    return false;
  }
  return true;
}



int factorialsProductTrailingZeros(int l, int r) {
 int result = 0,
                last = 0;
            for (int i = 1; i <= r; i++)
            {
                int number = i;
                while (number % 5 == 0)
                {
                    number /= 5;
                    last++;
                }
                if (i >= l)
                {
                    result += last;
                }
            }
            return result;
}

function bfsComponentSize(matrix) {

  var visited = [];
  var queue = [];
  var componentSize = 0;

  for (var i = 0; i < matrix.length; i++) {
    visited.push(false);
  }

  visited[1] = true;
  queue.push(1);
  while (queue.length) {
    var currentVertex = queue.shift();
    visited[currentVertex] = true;
    componentSize++;
    for (var nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
      if (matrix[currentVertex][nextVertex] && !visited[nextVertex]) {
        visited[nextVertex] = true;
        queue.push(nextVertex);
      }
    }
  }

  return componentSize;
}



int digitSum(int n) {
int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
}



 bool findPath(int[][] matrix)
        {
            int f = 0, c = 0;

            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] == 1)
                    {
                        f = i;
                        c = j;
                        goto e;
                    }
                }
            }

        e:
            //Console.WriteLine("hola");
            //int i = 
            int v =1;

            //int max = matrix.Length * matrix[0].Length;
            int n = matrix.Length;
            int m = matrix[0].Length;

            bool[][] marcas = new bool[n][];
            for (int i = 0; i < n; i++)
            {
                marcas[i] = new bool[m];
                for (int j = 0; j < m; j++)
                {
                    marcas[i][j] = false;
                }
            }

            marcas[f][c] = true;

            while (true)
            {
                if (f - 1 >= 0 && matrix[f - 1][c] == v + 1)
                {
                    marcas[f - 1][c] = true;
                    f--;
                    v++;
                }
                else if (f + 1 < matrix.Length && matrix[f + 1][c] == v + 1)
                {
                    marcas[f + 1][c] = true;
                    f++;
                    v++;

                }
                else if (c - 1 >= 0 && matrix[f][c - 1] == v + 1)
                {
                    marcas[f][c - 1] = true;
                    c--;
                    v++;
                }
                else if (c + 1 < matrix[0].Length && matrix[f][c + 1] == v + 1)
                {
                    marcas[f][c + 1] = true;
                    c++;
                    v++;
                }
                else
                {
                    break;
                }
            }

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < m; j++)
                {
                    if (!marcas[i][j])
                    {
                        return false;
                    }
                }
            }
            return true;
        }

--------------------------------------------

 static int[] Sum(int[] a)
        {
            //int sum = 0;
            List<int> lista = new List<int>();
            for(int i =0; i + 1<a.Length; i+=2)
            {
                //sum += a[i] + a[i + 1];
                lista.Add(a[i] + a[i + 1]);
            }
            return lista.ToArray();
        }

        static int[] Prod(int[] a)
        {
            //int prod = 1;
            List<int> lista = new List<int>();
            for(int i =0; i+1 < a.Length; i+=2)
            {
                //prod += a[i] * a[i + 1];
                lista.Add(a[i] * a[i + 1]);
            }
            return lista.ToArray();
        }
        static int arrayConversion(int[] inputArray)
        {

            if (inputArray.Length == 1) return inputArray.First();
            while (true)
            {
                 inputArray = Sum(inputArray);
                if (inputArray.Length == 1) return inputArray.First();
                inputArray = Prod(inputArray);
                if (inputArray.Length == 1) return inputArray.First();
            }
        }
-----------------------------------------



typedef std::vector<std::vector<char>> Canvas;

Canvas drawRectangle(Canvas canvas, std::vector<int> rectangle) {
  for (int i = rectangle[0] + 1; i < rectangle[2]; i++) {
    canvas[rectangle[1]][i] = '-';
    canvas[rectangle[3]][i] = '-';
  }
  for (int i = rectangle[1] + 1; i < rectangle[3]; i++) {
    canvas[i][rectangle[0]] = '|';
    canvas[i][rectangle[2]] = '|';
  }
  for (int i = 0; i < 4; i += 2) {
    for (int j = 1; j < 4; j+=2) {
      canvas[rectangle[j]][rectangle[i]] = '*';
    }
  }
  return canvas;
}





 static int chessKnightMoves(string cell)
        {
            int letra = (int)cell[0] - (int)'a' + 1;
            int num = (cell[1] - '0');

            // Console.WriteLine(letra + " " + num);

            int ans = 0;
            if (letra - 2 >= 1)
            {
                if (num + 1 <= 8)
                {
                    ans++;
                }
                 if (num - 1 >= 1)
                {
                    ans++;
                }
            }
            if (letra + 2 <=8)
            {
                if (num + 1 <= 8)
                {
                    ans++;
                }
                 if (num - 1 >= 1)
                {
                    ans++;
                }
            }


            if (num + 2 <= 8)
            {
                if (letra + 1 <= 8)
                {
                    ans++;
                }
                if (letra - 1 >= 1)
                {
                    ans++;
                }
            }

            if (num - 2 >=1 )
            {
                if (letra + 1 <= 8)
                {
                    ans++;
                }
                if (letra - 1 >= 1)
                {
                    ans++;
                }
            }



            return ans;
        }




static int maxSubmatrixSum(int[][] matrix, int n, int m)
        {

            int max_sum = int.MinValue;
            for (int i = 0; i < matrix.Length - n +1 ; i++)
            {
                for (int j = 0; j < matrix[i].Length - m+1 ; j++)
                {
                    int sum = 0;
                    for (int k = i; k < i + n ; k++)
                    {
                        for (int l = j; l < j + m ; l++)
                        {
                            sum += matrix[k][l];
                        }
                    }
                    max_sum = Math.Max(max_sum, sum);
                }

            }
            return max_sum;

        }

int sumBelowBound(int bound) {
 int sum = 0;
            
            
            for( int i = 1 ;  ;i++)
            {
                if(sum + i <= bound)
                {
                    sum += i;
                }
                else
                {
                    return i-1;
                }
            }

            return -1;
}


bool isSum(int value) {
	//sacado de -b+-sqrt(b^2 - 4ac)/2a
   return ((-1.0 + Math.Sqrt(1.0 + 8 * value)) / 2.0) % 1 ==0;
}


bool isSum(int value) {
	    for (int n = 1; n <= value; n++)
            {
                if ((n * (n + 1)) / 2 == value)
                {
                    return true;
                }
                if ((n * (n + 1)) / 2 > value) break;
            }
            return false;
}


bool leapYear(int year) {
  return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);

}


int fixedPointsPermutation(int[] permutation) {
int ans = 0;
            for(int i =0; i<permutation.Length; i++)
            {
                if(i+1 == permutation[i])
                {
                    ans++;
                }
            }
            return ans;
}


int centuryFromYear(int year) {
	    int century = 1;
            for(int i =1; ; i+=100)
            {
                if(year >= i && year <= i+99)
                {
                    return century;
                }
                century++;
            }
}


int pagesNumbering(int n) {
	    int cont = 0;
            for (int i=1; i<=n; i++)
            {
                //cont += i.ToString().Length;
                int copia = i;
                while(copia > 0)
                {
                    cont++;
                    copia /= 10;
                }
            }
            return cont;
}


private static boolean reverseToSort(ArrayList<Integer> inputArray) {

        for (int i = 0; i < inputArray.size(); i++) {
            for (int j = i + 1; j <= inputArray.size(); j++) {
                ArrayList<Integer> middle = new ArrayList<>(),
                        result = new ArrayList<>();
                result.addAll(inputArray.subList(0, i));
                middle.addAll(inputArray.subList(i, j));
                Collections.reverse(middle);
                result.addAll(middle);
                result.addAll(inputArray.subList(j, inputArray.size()));

                boolean correct = true;

                for (int k = 1; k < result.size(); k++) {
                    if (result.get(k - 1) >= result.get(k)) {
                        correct = false;
                        break;
                    }
                }
                if (correct) {
                    return true;
                }
            }
        }
        return false;
    }


String caesarBoxCipherEncoding(String s) {

        int c = (int) Math.sqrt(s.length());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < c; i++) {
            int j = i;
            while (j < s.length()) {

                sb.append(s.charAt(j));
                j+=c;
            }
        }

        return sb.toString();
    }


int arrayKthGreatestQuick(std::vector<int> inputArray, int k) {

  int pos = int(double(rand()) / RAND_MAX * inputArray.size());
  std::vector<int> left, right;

  if (inputArray.size() == 1) {
    return inputArray[0];
  }

  for (int i = 0; i < inputArray.size(); i++) {
    if(inputArray[i] < inputArray[pos]) left.emplace_back(inputArray[i]);
    else right.emplace_back(inputArray[i]);
  }

  if (right.size() >= k) {
    return arrayKthGreatestQuick(right, k);
  }
  return arrayKthGreatestQuick(left, k - right.size());
}



int toAndFro(int a, int b, int t) {
int len =  Math.abs(a-b);
  t %= (2 * len);
  if (t <= len) {
    return a + (b - a) / Math.abs(b - a) * t;
  }
  else {
    t -= len;
    return b + (a - b) / Math.abs(a - b) * t;
  }
}


int countSumOfTwoRepresentations(int n, int l, int r) {
    var count = 0;
    for (var a = l; a <= r; a++)
        if (a <= n - a && n - a >= l && n - a <= r)
            count++;

    return count;
}


int smallestMultiple(int left, int right) {
            for(int i =1; ;i++)
            {
                bool flag = true;
                for(int j =left; j<= right; j++)
                {
                    if (i % j != 0)
                    {
                        flag = false;
                    }
                }
                if (flag) return i;
            }
}



int equidistantTriples(int[] coordinates) {

  int ans = 0;
  for (int i = 1; i < coordinates.length - 1; i++) {
    int left = i - 1;
    int right = i + 1;
    while (left >= 0 && right < coordinates.length) {
      int distL =  coordinates[i] -coordinates[left]  ;
      int distR = coordinates[right] - coordinates[i];
      if (distL == distR) {
        ans++;
        left--;
        right++;
      } else if (distL < distR) {
        left--;
      } else {
        right++;
      }
    }
  }

  return ans;
}


int maxSubarray(int[] a) {
    int max_so_far = a[0]; 
    int curr_max = a[0]; 
     int size = a.Length;
    for (int i = 1; i < size; i++) 
    { 
        curr_max = Math.Max(a[i], curr_max+a[i]); 
        max_so_far = Math.Max(max_so_far, curr_max); 
    } 
  
    if(max_so_far < 0 ) return 0;
    return max_so_far; 
}


int houseNumbersSum(int[] inputArray) {
     int sum = 0;
            for(int i =0; i < inputArray.Length && inputArray[i] != 0; i++)
            {
                sum += inputArray[i];
            }
            return sum;
}


bool isIdentityMatrix(std::vector<std::vector<int> > matrix) {
	
	for(int i =0; i<matrix.size(); i++) {
		
		for(int j =0; j<matrix[i].size(); j++ ) {
			if(i == j) {
				if(matrix[i][j] != 1) {
					return false;
				}
			}
			else{
				if(matrix[i][j] !=0) return false;
			}
		}
		
	}
	
	return true;
	
}

int stringsConstruction(std::string a, std::string b) {
        map<char, int> hash_a;
	map<char, int> hash_b;
	
	for(int i =0; i<a.size(); i++) {
		hash_a[a[i]]++;
	}
	
	for(int i =0; i<b.size(); i++) {
		hash_b[b[i]]++;
	}
	
	int m = INT_MAX;
	for(int i =0; i<a.size(); i++) {
		m =  min(m,  hash_b[a[i]] / hash_a[a[i]]);
	}
	
	return m;
}

def binaryPower(n, k):
    MOD = 10 ** 7 + 7

    if k == 0:
        return 1
    if k % 2 == 0:
        return (binaryPower(n, k // 2)**2) % MOD
    return (binaryPower(n, k - 1) * n) % MOD



string buildPalindrome(string st) {
int i = 0;
            for (  ; i < st.Length; i++)
            {
                string subs = st.Substring(i, st.Length - i );
                char[] ch = subs.ToCharArray();
                Array.Reverse(ch);
                if (subs == new string(ch))
                {
                    break;
                }
            }

            string pre = st.Substring(0, i);
            char[] rev_pre = pre.ToCharArray();
            Array.Reverse(rev_pre);
            return st + new string(rev_pre);
}


bool equationTemplate(int[] values) {
	    Array.Sort(values);

            int a = values[0];
            int b = values[1];
            int c = values[2];
            int d = values[3];

            return a * b * c == d ||
                   a * b == c * d ||
                   a * c == b * d ||
                   a * d == b * c ||
                   a * b * d == c ||
                   a * c * d == b || 
                   b * c * d == a;
}


int nearestSmallerEqFib(int n) {
       
        if (n == 0 || n == 1)
            return n;

       
        int f1 = 0, f2 = 1, f3 = 1;
        while (f3 <= n) {
            f1 = f2;
            f2 = f3;
            f3 = f1 + f2;
        }
        return f2;
    }

      int[] fibonacciSum(int n) {
        ArrayList<Integer> fibSumArr = new ArrayList<>();
        while (n > 0) {
           
            int f = nearestSmallerEqFib(n);

            
            fibSumArr.add(f);

           
            n = n - f;
        }
        Collections.reverse(fibSumArr);
        return fibSumArr.stream().mapToInt(i -> i).toArray();
    }


int kthDivisor(int n, int k) {
int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                if (n % i == 0)
                {
                    cont++;
                }
                if (cont == k) return i;
            }
            return -1;
}


def variableName(name):
    if name[0].isdigit():
        return False
    for e in name:

        if (e >='A' and e <= 'Z') or (e >='a' and e <= 'z') or e == '_' or (e >='0' and e <= '9'):
            pass
        else:
            return False
    return True


int[] powersOfTwo(int n) {
        ArrayList<Integer> ans = new ArrayList<>();
        int cur = 1;
        while (n > 0) {
            if ((n & 1) != 0) {
                ans.add(cur);
            }
            n >>= 1;
            cur <<= 1;
        }

        int[] a = new int[ans.size()];
        for (int i = 0; i < a.length; i++) {
            a[i] = ans.get(i);
        }

        return a;
}



int arraySumAdjacentDifference(int[] inputArray) {
	    int sum = 0;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                sum += Math.Abs(inputArray[i] - inputArray[i + 1]);
            }
            return sum;
}


int[] robotPath(string instructions, int bound) {
            int[] dx = { -1, 0, 1, 0 };
            int[] dy = { 0, 1, 0, -1 };
            int x = 0, y = 0;
            string dirs = "LURD";

            for (int i = 0; i < instructions.Length; i++)
            {
                int j = dirs.IndexOf(instructions[ i]);
                if (Math.Abs(x + dx[j]) <= bound &&
                    Math.Abs(y + dy[j]) <= bound)
                {
                    x += dx[j];
                    y += dy[j];
                }
            }

            return new int[] { x, y };
}



string reduceString(string inputString) {
int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] == inputString[j])
                {
                    i++;
                    j--;
                }
                else
                {
                    break;
                }
            }

            string ans = inputString.Substring(i,j-i+1);
            if (ans.Length == 1) return "";
            return ans;
}

int oddNumbersBeforeZero(int[] sequence) {
int odds = 0;
            
            for (int i = 0; i < sequence.Length; i++)
            {
                if (sequence[i] == 0) break;
                if (sequence[i] % 2 != 0) odds++;
            }
            return odds;
}


int countSumOfTwoRepresentations2(int n, int l, int r) {
   int result = 0;

    for (int a = l; a <= r; a++) {
        int b = n - a;
        if (b >= l && b <= r && b >= a) {
            result++;
        }
    }
    return result;
}


int equalPairOfBits(int n, int m) {
	return n + m + 1 & ~m - n ;
}



string lineEncoding(string s) {
     int cont = 1;
            char actual = s[0];
            string ans = "";
            for (int i = 1; i < s.Length; i++)
            {
                if (actual == s[i])
                {
                    cont++;
                }
                else
                {
                    if (cont > 1)
                    {
                        ans += cont + "" + actual;
                    }
                    else
                    {
                        ans += actual;
                    }
                    cont = 1;
                }
                actual = s[i];
            }
            if (cont > 1)
            {
                ans += cont + "" + actual;
            }
            else
            {
                ans += actual;
            }

            return ans;
}





bool symbolsPermutation(string word1, string word2) {
char[] ch1 = word1.ToCharArray();
            Array.Sort(ch1);
            char[] ch2 = word2.ToCharArray();
            Array.Sort(ch2);
            return new string(ch1) == new string(ch2);
}

bool checkEqualFrequency(int[] inputArray) {
  Dictionary<int, int> dic = new Dictionary<int, int>();
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (dic.ContainsKey(inputArray[i]))
                {
                    dic[inputArray[i]]++;
                }
                else
                {
                    dic[inputArray[i]] = 1;
                }

            }

            return dic.Values.ToArray().Distinct().ToArray().Length == 1;
}



int differentSquares(int[][] matrix) {
            HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i +1 < matrix.Length; i++)
            {
                for (int j = 0; j  + 1< matrix[i].Length; j++)
                {
                    hash.Add(matrix[i][j] + " " + matrix[i][j + 1] + " "
                        + matrix[i + 1][j] + " " + matrix[i + 1][j + 1]);

                }
            }
            return hash.Count;
}


bool willYou(bool young, bool beautiful, bool loved) {
     bool c1 = (young && beautiful) && !loved;
            bool c2 = loved && (!young || !beautiful);

            return c1 || c2;
}



bool increaseNumberRoundness(int n) {
    while (n % 10 == 0)
            {
                n /= 10;
            }

            string s = n.ToString();

            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] == '0')
                {
                    return true;
                }
            }
            return false;
}


int differentValues(std::vector<int> a, int d) {

  int best = -1;
  for (int i = 0; i < a.size(); i++) {
    for (int j = i + 1; j < a.size(); j++) {
      int diff = abs(a[j] - a[i]);
      if (diff <= d && best < diff) {
        best = diff;
      }
    }
  }

  return best;
}


int[] primeFactors(int n) {
          List<int> hash = new List<int>();
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                hash.Add(2);
                n /= 2;
            }


            for (int i = 3; i * i <= n; i += 2)
            {

                while (n % i == 0)
                {

                    hash.Add(i);
                    n /= i;
                }
            }


            if (n > 2)
            {

                hash.Add(n);
            }
            return hash.ToArray();
}




int matrixElementsSum(int[][] matrix) {
	int sum =0;
        for(int i =0; i<matrix[0].length;i++) {
            for(int j=0; j<matrix.length;j++) {
                if(matrix[j][i] > 0)
                    sum +=matrix[j][i];
                else
                    break;
            }
        }
        return sum;
}



bool isInsideTheCircle(int xa, int ya, int xc, int yc, int rc) {
  int dist = (xa - xc) * (xa - xc) + (ya - yc) * (ya - yc);
  rc *= rc;
  if (dist < rc) {
    return true;
  }
  return false;
}


bool checkIncreasingSequence(int[] seq) {
     for (int i = 0; i + 1 < seq.Length; i++)
            {
                if (seq[i + 1] <= seq[i])
                {
                    return false;
                }
            }
            return true;
}


int matrixTrace(int[][] matrix) {
int sum = 0;
            for (int i = 0; i < matrix.Length; i++)
            {
                sum += matrix[i][i];
            }
            return sum;
}



int[][] meanGroups(int[][] a) {
 Dictionary<double, List <int> > dic = new Dictionary<double, List<int>>();
            //int[][] ans = new int[a.Length][];
            for (int i = 0; i < a.Length; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < a[i].Length; j++)
                {
                    sum += a[i][j];
                }
                double prom = sum / a[i].Length;

                if (dic.ContainsKey(prom))
                {
                    dic[prom].Add(i);
                }
                else
                {
                    dic[prom] = new List<int>();
                    dic[prom].Add(i);
                }

            }

            int[][] res = new int[dic.Count ][];
            int k =0;
            foreach (KeyValuePair<double, List<int>> kvp in dic)
            {
                List<int> lista_values = kvp.Value;
                lista_values.Sort();
                int[] vals = lista_values.ToArray();
                res[k++] = vals.ToArray(); 
            }

            return res;
}



static int countTinyPairs(int[] a, int[] b, int k)
        {
            //HashSet<string> hash = new HashSet<string>();

            int ans = 0;
             
            for (int i = 0; i < a.Length; i++)
            {
                 int x = int.Parse(  a[i] + "" + b[a.Length - i-1] );
                 if (x < k)
                 {
                     ans++;
                 }
            }


            return ans;
        }


int maxFraction(int[] numerators, int[] denominators) {
	    double max = 0.0;
            int ans = -1;
            for (int i = 0; i < numerators.Length; i++)
            {
                double f = (double) numerators[i] / (double) denominators[i];
                if (f > max)
                {
                    max = f;
                    ans = i;
                }
            }
            return ans;
}


int champernowneDigit(int n) {
 string s = "";
            for (int i = 1; i <= n; i++)
            {
                s += i.ToString() ;
            }
            return int.Parse(s[n-1].ToString());
}



int equationSolutions(int l, int r) {
    HashSet<string> pares = new HashSet<string>();
            for (int a = l; a <= r; a++)
            {
                for (int b = l; b <= r; b++)
                {
                    int cubo = a * a * a;
                    int cuad = b * b;

                    if (cuad == cubo)
                    {
                        pares.Add(Math.Min(a, b) + " " + Math.Max(a, b));
                    }
                }
            }
            return pares.Count;
}


def fileNaming(names):
    def calculateHash(inputString):
        P = 307
        M = 1000003
        hashValue = 0
        for i in range(len(inputString)):
            hashValue = (hashValue * P + ord(inputString[i])) % M
        return hashValue

    hashMapSize = len(names) * 2
    ##
    #     Information about the string in the hash map
    #     is stored in the following way:
    #     [string itself,
    #      its hash,
    #      the smallest possible integer to use with this name]
    ##
    hashMap = []
    result = []

    def searchHM(position, hashValue):
        while (hashMap[position][0] != ''
          and hashMap[position][1] != hashValue):
            position = (position + 1) % hashMapSize
        return position

    for i in range(hashMapSize):
        hashMap.append(['', -1, 0])

    for i in range(len(names)):
        hashValue = calculateHash(names[i])
        startPos = searchHM(hashValue % hashMapSize, hashValue)
        if hashMap[startPos][0] == '':
            hashMap[startPos] = [names[i], hashValue, 1]
            result.append(names[i])
        else:
            newName = names[i] + '(' + str(hashMap[startPos][2]) + ')'
            newNameHash = calculateHash(newName)
            position = searchHM(newNameHash % hashMapSize, newNameHash)

            while hashMap[position][0] != '':
                hashMap[startPos][2] += 1
                newName = names[i] + '(' + str(hashMap[startPos][2]) + ')'
                newNameHash = calculateHash(newName)
                position = searchHM(newNameHash % hashMapSize, newNameHash)
            hashMap[position] = [newName, newNameHash, 1]
            result.append(newName)
            hashMap[startPos][2] += 1

    return result


string caseUnification(string s)
        {
            int lower = 0, upper = 0;

            for (int i = 0; i < s.Length; i++)
            {
                if (char.IsUpper(s[i]))
                {
                    upper++;
                }
                else
                {
                    lower++;
                }
            }

            return upper > lower ? s.ToUpper() : s.ToLower();

        }


String decipher(String cipher) {

  String result = "";
  for (int i = 0; i < cipher.length(); ) {
    int len;
    if (cipher.charAt(i) == '1') {
      len = 3;
    } else {
      len = 2;
    }
    int code = Integer.parseInt(cipher.substring(i, i+len));
    result += (char) code;
    i += len;
  }

  return result;
}


int countWaysToChangeDigit(int value) {
        int ans = 0;
        while (value > 0) {
            ans += 9 - value % 10;
            value /= 10;
        }
        return ans;
}


int avoidObstacles(int[] inputArray) {

            //Array.Sort(inputArray);---->no
            int max = inputArray.Max();

            for (int dist = 1; dist <= max ; dist++)
            {
                HashSet<int> hash = new HashSet<int>();
                for (int i = 0; i<= max ; i += dist)
                {
                    hash.Add(i);
                }
                int j = 0;
                for (; j < inputArray.Length; j++)
                {
                    if (hash.Contains(inputArray[j]))
                    {
                        break;
                    }
                }
                if (j >= inputArray.Length)
                {
                    return dist;
                }

            }
            return max +1;
}



int uniqueDigitProducts(int[] a) {
           HashSet<int> hash = new HashSet<int>();
            for (int i = 0; i < a.Length; i++)
            {
                int copia = a[i];
                int prod = 1;
                while (copia > 0)
                {
                    prod *= copia % 10;
                    copia /= 10;
                }
                hash.Add(prod);
            }
            return hash.Count;
}



std::vector<int> fractionSubtraction(std::vector<int> a, std::vector<int> b) {
    vector<int> fraction = { a[0] * b[1] - a[1] * b[0], a[1] * b[1] };

        int div = min(fraction[0], fraction[1]);
        while (div != 1) {
            if (fraction[0] % div == 0 && fraction[1] % div == 0) {
                fraction[0] /= div;
                fraction[1] /= div;
                div = min(fraction[0], fraction[1]);
            } else
                div--;
        }
        return fraction;
}


int maxMultiple(int divisor, int bound) {
    
            for (int n = bound; n >= 1; n-- )
            {
                if (n % divisor == 0) return n;
            }
            return -1;
}



 static int specialPolynomial(int x, int n)
        {
            double sum = 0;
            int k = 0;
            for (; ; k++)
            {
                if (sum + Math.Pow(x, k) > n)  break;
                sum += Math.Pow(x, k);
            }
            return k - 1;
        }

string findEmailDomain(string address) {
int indiceArroba = address.LastIndexOf('@');
            return address.Substring(indiceArroba + 1, address.Length - indiceArroba - 1);

}


int sumOfSquares(int n) {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i ;
            }
            return sum;
}



string lookAndSaySequenceNextElement(string element) {
     string s = "";
            char actual = element[0];
            int cont = 1;
            for (int i = 1; i < element.Length; i++)
            {
                if (actual == element[i])
                {
                    cont++;
                }
                else
                {
                    s += cont + "" + actual;
                    actual = element[i];
                    cont = 1;
                }
            }

            if (cont >= 1)
            {
                s += cont + "" + actual;
            }

            return s;
}



static string[] addBorder(string[] picture)
        {
            string[] ans = new string[picture.Length + 2];

            int k = 0;
            for (int i = 0; i < ans.Length; i++)
            {
                if (i == 0 || i == ans.Length -1 )
                {
                    ans[i] = new string('*', picture[0].Length + 2);
                }
                else
                {
                    string fila = "";
                    fila += '*';
                    fila += picture[k] + '*';
                    ans[i] = fila;
                    k++;
                }
            }
            return ans;
        }


def polishNotation(tokens):
    def isNumber(stringRepresentation):
        return (len(stringRepresentation) > 1 or
              '0' <= stringRepresentation[0] and
              stringRepresentation[0] <= '9')

    stack = []

    for i in range(len(tokens)):
        stack.append(tokens[i])
        while (len(stack) > 2 and isNumber(stack[-1])
          and isNumber(stack[-2])):
            leftOperand = int(stack[-2]) 
            rightOperand = int(stack[-1])
            result = 0
            if stack[-3] == '-':
                result = leftOperand - rightOperand
            if stack[-3] == '+':
                result = leftOperand + rightOperand
            if stack[-3] == '*':
                result = leftOperand * rightOperand
            stack = stack[:-3]
            stack.append(str(result))

    return int(stack[0])



int arrayMaxConsecutiveSum(int[] inputArray, int k) {
            int sum = 0;
            for (int i = 0; i < k; i++)
            {
                sum += inputArray[i];
            }
            int max = sum;

            for (int i = 0; i + k < inputArray.Length; i++)
            {
                sum += inputArray[i + k];
                sum -= inputArray[i];
                max = Math.Max(max, sum);
            }
            return max;
}




bool isCaseInsensitivePalindrome(string inputString) {
    inputString = inputString.ToLower();
            int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] != inputString[j]) return false;

                i++;
                j--;
            }
            return true;
}



 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        } 
         int[] fractionReducing(int[] fraction)
        {
            int g = gcd(fraction[0], fraction[1]);
            fraction[0] /= g;
            fraction[1] /= g;
            return fraction;
        }


string compareIntegers(string a, string b) {
    if (a.Length < b.Length) return "less";
            if (a.Length > b.Length) return "greater";

            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] - '0' > b[i] - '0')
                {
                    return "greater";
                }
                else if (a[i] - '0' < b[i] - '0')
                {
                    return "less";
                }
            }

            return "equal";
}


int[] makeArrayConsecutive(int[] sequence) {
    int min = sequence.Min(), max = sequence.Max();
            HashSet<int> hash = new HashSet<int>(sequence);

            List<int> ans = new List<int>();
            for (int i = min; i <= max; i++)
            {
                if (!hash.Contains(i))
                {
                    ans.Add(i);
                }
            }

            return ans.ToArray();
}



   static int maximalEven(int[] inputArray)
        {
            int max = 0;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] % 2 == 0)
                {
                    if (inputArray[i] > max)
                    {
                        max = inputArray[i];
                    }
                }
            }
            return max;
        }



string longestWord(string text) {
         string w = "";
            string max_w = "";
            for (int i = 0; i < text.Length; i++)
            {
                if ((text[i] >= 'a' && text[i] <= 'z') ||
                    (text[i] >= 'A' && text[i] <= 'Z'))
                {
                    w += text[i];
                }
                else
                {
                    w = "";
                }
                if (w.Length > max_w.Length)
                {
                    max_w = w;
                }
            }
            return max_w; 
}

bool alphabetSubstring(string s) {
     for (int i = 0; i + 1 < s.Length; i++)
            {
                if (s[i] + 1 != s[i+1])
                {
                    return false;
                }
            }
            return true;
}



int graphEdges(bool[][] matrix) {
	int c = 0;

        for (int i = 0; i < matrix.Length; ++i)
            for (int j = 0; j < matrix[i].Length; ++j)
                if (matrix[i][j])
                    ++c;

        return c / 2;
}


bool evenDigitsOnly(int n) {

  if (n == 0) {
    return true;
  }
  if (n % 2 != 0) {
    return false;
  }
  return evenDigitsOnly(n / 10);
}



int leastCommonMultiple(int a, int b) {

  int gcd = 1;
  for (int divisor = 2; divisor <= std::min(a, b); divisor++) {
    if (a % divisor == 0 && b % divisor == 0) {
      gcd = divisor;
    }
  }

  return a * b / gcd;
}

        static int[] onlyEvenNumbers(int left, int right)
        {
            List<int> ans = new List<int>();
            for (int i = left; i <= right; i++)
            {
                if (i % 2 == 0)
                {
                    ans.Add(i);
                }
            }
            return ans.ToArray();
        }

int factorizedGCD(int[] a, int[] b) {
  int j = 0,
      result = 1;
  for (int i = 0; i < a.length; i++) {
    while (j< b.length && a[i] > b[j]) {
      j++;
    }
    if (j < b.length && a[i] == b[j]) {
      result *= a[i];
      j++;
    }
  }
  return result;
}



int swapNeighbouringDigits(int n) {
     char[] ch = (n + "").ToCharArray();

            for (int i = 0; i + 1 < ch.Length; i+=2)
            {
                char temp = ch[i];
                ch[i] = ch[i + 1];
                ch[i + 1] = temp;
            }
            return int.Parse( new string(ch));
}




int isSumOfConsecutive2(int n) {
	     int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                int sum = 0;
                for (int j = i; j <= n; j++)
                {
                    sum += j;
                    if (sum == n)
                    {
                        cont++;
                        break;
                    }
                    if (sum > n)
                    {
                        break;
                    }
                }
            }
            return cont-1;
}


bool isDiagonalMatrix(int[][] matrix) {
for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (i != j)
                    {
                        if (matrix[i][j] != 0) return false;
                    }
                }
            }
            return true; 
}


int reverseBits(int n) {
  int res = 0;
  for (int i = 0; i < 16; i++) {
    res = res * 2 + (n % 2);
    n /= 2;
  }
  return res;
}


typedef std::vector<std::string> elemT;
typedef std::vector<elemT> listT;
listT superResources(listT requests) {

  struct Helper {
    bool le(std::string const & a, std::string const & b) {
      return std::stoi(a) <= std::stoi(b);
    }
  };
  Helper h;

  if (requests.size() < 2) {
    return requests;
  }
  listT parts[2] = {
      listT(requests.begin(), requests.begin() + requests.size() / 2),
      listT(requests.begin() + requests.size() / 2, requests.end())
  };
  parts[0] = superResources(parts[0]);
  parts[1] = superResources(parts[1]);

  listT result;
  int idx[2] = {0, 0};
  int len[2] = {parts[0].size(), parts[1].size()};
  std::string last = "";
  while (idx[0] < len[0] || idx[1] < len[1]) {
    int k;
    if (idx[1] >= len[1] || idx[0] < len[0] &&
        h.le(parts[0][idx[0]][0], parts[1][idx[1]][0])) {
      k = 0;
    } else {
      k = 1;
    }
    elemT element = parts[k][idx[k]++];
    if (element[0] != last) {
      result.push_back(element);
      last = element[0];
    }
  }

  return result;
}


----------------------------------
   HashSet<int> primeFactors(int n)
        {
            HashSet<int> p = new HashSet<int>();
            // Print the number of 2s that divide n 
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                p.Add(2);
                n /= 2;
            }

            // n must be odd at this point. So we can 
            // skip one element (Note i = i +2) 
            for (int i = 3; i <= Math.Sqrt(n); i += 2)
            {
                // While i divides n, print i and divide n 
                while (n % i == 0)
                {
                    //Console.Write(i + " ");
                    p.Add(i);
                    n /= i;
                }
            }

            // This condition is to handle the case whien 
            // n is a prime number greater than 2 
            if (n > 2) p.Add(n);
                //Console.Write(n);

            return p;
        } 
      

         int leastCommonPrimeDivisor(int a, int b)
        {
            HashSet<int> pa = primeFactors(a);
            HashSet<int> pb = primeFactors(b);

            foreach (int item in pa)
            {
                if (pb.Contains(item))
                {
                    return item;
                }
            }

            return -1;
        } 


bool isLuckyNumber(int n) {
while (n > 0)
            {
                if (n % 10 != 4 && n % 10 != 7) return false;
                n /= 10;

            }
            return true;
}

  
  bool checkPalindrome(string inputString)
        {

            int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] != inputString[j]) return false;
                i++;
                j--;
            }
            return true;
        }

String buildPalindrome(String st) {
  boolean canConvert;
  for (int i = st.length(); ; i++) {
    canConvert = true;
    for (int j = 0; j < i - j - 1; j++) {
      if (i - j - 1 < st.length() && st.charAt(j) != st.charAt(i - j - 1)) {
        canConvert = false;
        break;
      }
    }
    if (canConvert) {
      for (int j = st.length(); j < i; j++) {
        st += String.valueOf(st.charAt(i-j-1 ));
      }
      return st;
    }
  }
}


bool isMonotonous(int[] sequence) {
   bool incrementa = true;
            bool decrementa = true;
            for (int i = 0; i + 1 < sequence.Length; i++)
            {
                if (sequence[i + 1] <= sequence[i])
                {
                    incrementa = false;
                    break;
                }
            }
            for (int i = 0; i + 1 < sequence.Length; i++)
            {
                if (sequence[i + 1] >= sequence[i])
                {
                    decrementa  = false;
                    break;
                }
            }
            return incrementa || decrementa;
}

int kthDigit(int n, int k) {

  int numDigits = 0, number = n;
  while (number) {
    numDigits++;
    number /= 10;
  }

  int indexFromLast = numDigits -  k + 1;

  while (n) {
    if (--indexFromLast == 0) {
      return n % 10;
    }
    n /= 10;
  }

  return -1;
}


int[][] create2DArray(int[] lengths) {
      int[][] ans = new int[lengths.Length][];
            for (int i = 0; i < lengths.Length; i++)
            {
                ans[i] = new int[lengths[i]];
                for (int j = 0; j < lengths[i]; j++)
                {
                    ans[i][j] = j;
                }
            }
            return ans;
}

int digitDegree(int n){

  struct Helper {
    int digitSum(int n) {
      int sum = 0;
      while (n != 0) {
        sum += n % 10;
        n /= 10;
      }
      return sum;
    }
  };
  Helper h;

  int result = 0;

  while (n > 9) {
    result++;
    n = h.digitSum(n);
  }

  return result;
}


int kthDigit(int n, int k) {
  return k > (n + "").Length ? -1 : (n + "")[k - 1] - '0';
}


int numbersGrouping(int[] a) {
HashSet<int> hash = new HashSet<int>();

            for (int i = 0; i < a.Length; i++)
            {
                hash.Add( (a[i] - 1) / 10000);
            }
            return hash.Count + a.Length;
}


int arrayChange(int[] inputArray) {
            int ans = 0;
            for (int i = 1; i < inputArray.Length; i++)
            {
                if (inputArray[i - 1] >= inputArray[i])
                {
                    ans += inputArray[i - 1] - inputArray[i] + 1;
                    inputArray[i] = inputArray[i - 1] + 1;
                }
            }
            return ans;
}



int myMaxOfThree(int a, int b, int c) {
	    if (a > b && a > c) return a;
            if (b > c) return b;
            return c;
}



int kthDigit(int n, int k) {
      int rev = 0;

            while (n > 0)
            {
                rev = rev * 10 + n % 10;
                n /= 10;
            }
            int cont = 1;
            while (rev > 0)
            {
                if (cont == k)
                {
                    return rev % 10;
                }
                cont++;
                rev /= 10;
            }
            return -1;
}

bool cyclicSequence(int[] sequence) {
  int ind_min = Array.IndexOf(sequence, sequence.Min());

            int[] ordenado = new int[sequence.Length];
            int k = 0;
            for (int i = ind_min; i < sequence.Length; i++)
            {
                ordenado[k++] = sequence[i];
            }
            for (int i = 0; i < ind_min; i++)
            {
                ordenado[k++] = sequence[i];
            }
            for (int i = 0; i + 1 < ordenado.Length; i++)
            {
                if (ordenado[i + 1] <= ordenado[i])
                {
                    return false;
                }
            }
            return true;
}


int powerRecursive(int x, int exponent) {
  if (exponent == 0) {
    return 1;
  }
  else{
    return x *  powerRecursive( x,  exponent - 1);
  }
}



string swapCase(string text) {
     string s = "";
            for (int i = 0; i < text.Length; i++)
            {
                if (char.IsLower(text[i]))
                {
                    s += char.ToUpper(text[i]);
                }
                else
                {
                    s += char.ToLower(text[i]);
                }
            }
            return s;
}


string[] isDivisibleBy3(string inputString) {
     List<string> ans = new List<string>();
            for (char ch = '0'; ch <= '9'; ch++)
            {
                string s = inputString.Replace('*', ch);
                int sum = s.Sum(e => e - '0');
                if (sum % 3 == 0) ans.Add(s);
            }
            return ans.ToArray();
}
 

int divisorsPairs(int[] sequence) {
 HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i < sequence.Length; i++)
            {
                for (int j = i + 1; j < sequence.Length; j++)
                {
                    int max = Math.Max(sequence[i], sequence[j]);
                    int min = sequence[i] + sequence[j] - max;

                    if (max % min == 0)
                    {
                        hash.Add(min + " " + max);
                    }
                }
            }
            return hash.Count;
}

 static bool areSimilarNumbers(int a, int b, int divisor)
        {
            return (a % divisor == 0 && b % divisor == 0) ||
                  (a % divisor != 0 && b % divisor != 0);
        }

        int maxDivisor(int left, int right, int divisor)
        {
            for (int i = right; i >= left; i--)
            {
                if (i % divisor == 0) return i;
            }
            return -1;
        }


boolean orthogonalLines(int[] line1, int[] line2) {
int sum=0;
    for(int i =0; i<line1.length-1; i++)
    {
        sum += line1[i] * line2[i];
    }
    if (sum ==0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}


int sumOfMultiples(int n, int k) {
int sum = 0;
            for (int i = k; i <= n; i += k)
            {
                sum += i;
            }
            return sum;
}


int divNumber(int k, int l, int r)
        {
            int ans = 0;
            for (int i = l; i <= r; i++)
            {
                int div = 0;
                for (int j = 1; j <= i; j++)
                {
                    if (i % j == 0)
                    {
                        div++;
                    }

                }
                if (div == k)
                {
                    ans++;
                }

            }
            return ans;

        }


int numbersGrouping(int[] a) {
    List<int> nGroupList = new List<int>();
    for(int i=0;i<100000;i++) {
        nGroupList.Add(0);
    }
    int len = a.Length;
    for(int i=0;i<len;i++) {
        int index = (a[i]-1)/10000;
        if(nGroupList[index]==0)
            nGroupList[index]+=2;
        else
            nGroupList[index]++;
    }
     
    return nGroupList.Sum();
}

 static int numbersGrouping(int[] a)
        {
            HashSet<int> hs = new HashSet<int>();
            foreach (int n in a)
            {
                //hs.Add(grupo(elem));
                int g1 = 0;
                if (n <= 10000)
                {
                    hs.Add(0);
                    continue;
                    //return 0;
                }

                string ns = n.ToString();
                string g = ns.Substring(0, ns.Length - 5 + 1);

                string resto = ns.Substring(ns.Length - 5, 5);
                //Console.WriteLine(resto);

                string ultimo = "";
                ultimo += resto[0].ToString() + new string('0', resto.Length - 1);
                // Console.WriteLine(ultimo);

                g1 = int.Parse(g);
                if (resto == ultimo)
                {
                    g1--;
                }

                hs.Add(g1);
            }
            return hs.Count + a.Length;
        }


static  bool isIncreasingDigitsSequence(int n)
        {
            int dig = n % 10;
            n /= 10;
            while (n > 0)
            {
                if (n % 10 >= dig)
                {
                    return false;
                }
                dig = n % 10;
                n /= 10;
            }
            return true;
        }

int factorialTrailingZeros(int n) {
int result = 0;
  for (int i = 5; i <= n; i += 5) {
    int number = i;
    while (number % 5 == 0) {
      number /= 5;
      result++;
    }
  }
  return result;
}

double[] quadraticEquation(int a, int b, int c) {
	    int discriminant = b * b - 4 * a * c;
            if (discriminant < 0)
            {
                List<Double> empty = new List<Double>();
                return empty.ToArray();
            }
            if (discriminant == 0)
            {
                List<Double> answer = new List<Double>();
                answer.Add(-b / (2.0 * a));
                return answer.ToArray();
            }
            List<Double> roots = new List<Double>();
            roots.Add((-b - Math.Sqrt(discriminant)) / (2.0 * a));
            roots.Add((-b + Math.Sqrt(discriminant)) / (2.0 * a));
            if (roots[0] > roots[1])
            {
                double tmp = roots[1];
                roots[1] = roots[0];
                roots[0] = tmp;
            }
            return roots.ToArray();
}


 static int sumUpDigits(string inputString)
        {
            int sum = 0;
            for (int i = 0; i < inputString.Length; i++)
            {
                if (inputString[i] >= '0' && inputString[i] <= '9')
                {
                    sum += (inputString[i] - '0');
                }
            }
            return sum;
        }


 public static int exerciseElaboration(int p, int n) {

        StringBuilder sb = new StringBuilder();
        sb.append(p);
        for (int i = 0; i < n; i++)
            sb.append('0');
        sb.append(p);
        BigInteger b = new BigInteger(sb.toString());
        String s = b.multiply(b).toString();
        int result = 0;
        for (char c : s.toCharArray())
            result += c - '0';

        return result;

    }

std::string knapsackLight2(int weight1, int weight2, int maxW) {
if (weight1 + weight2 <= maxW) {
    return "both";
  }
  if (std::min(weight1, weight2) > maxW) {
    return "none";
  }
  if (std::max(weight1, weight2) <= maxW) {
    return "either";
  }
  if (weight1 <= maxW) {
    return "first";
  }
  return "second";
}



string concatenationProcess(string[] initialArray) {
            List<string> r = new List<string>(initialArray);
            while (r.Count > 1)
            {
                int min = int.MaxValue;
                int mini = -1;
                for (int i = 0; i < r.Count; i++)
                {
                    if (r.ElementAt(i).Length < min)
                    {
                        min = r.ElementAt(i).Length;
                        mini = i;
                    }
                }
                int min2 = int.MaxValue;
                int mini2 = -1;
                for (int i = r.Count - 1; i >= 0; i--)
                {
                    if (i != mini && r.ElementAt(i).Length < min2)
                    {
                        min2 = r.ElementAt(i).Length;
                        mini2 = i;
                    }
                }
                string neu = r.ElementAt(mini) + r.ElementAt(mini2);
                if (mini < mini2)
                {
                    r.RemoveAt(mini2);
                    r.RemoveAt(mini);
                }
                else
                {
                    r.RemoveAt(mini);
                    r.RemoveAt(mini2);
                }
                r.Add(neu);
            }
            return r.First();
}

int countIncreasingSequences(int n, int k) {
    int u=1;
    for (int i=0; i<n; i++)
        u=((k-i)*u)/(i+1);
    return u;
}


string removeDuplicateCharacters(string str) {
Dictionary<char, int> hash = new Dictionary<char, int>();
            for (int i = 0; i < str.Length; i++)
            {
                if (hash.ContainsKey(str[i]))
                {
                    hash[str[i]]++;
                }
                else
                {
                    hash[str[i]] = 1;
                }
            }

            string s = "";
            for (int i = 0; i < str.Length; i++)
            {
                if (hash[str[i]] == 1)
                {
                    s += str[i];
                }
            }
            return s;
}


    private static int quasifactorial(int n) {
        int answer = 1;
        for (int i = 2; i <= n; ++i) {
            answer *= i;
            --answer;
        }
        return answer;
    }


boolean chessBoardCellColor(String cell1, String cell2) {
 if((cell1.charAt(0) + cell1.charAt(1)) % 2 == 0 &&
        		(cell2.charAt(0) + cell2.charAt(1)) % 2 == 0 ||
        		(cell1.charAt(0) + cell1.charAt(1)) % 2 != 0 &&
        		(cell2.charAt(0) + cell2.charAt(1)) % 2 != 0) {
        	return true;

        }
        return false;
}



bool isIPv4Address(std::string inputString) {

  int currentNumber = 0;
  bool emptyField = true;
  int countNumbers = 0;

  inputString += '.';

  for (int i = 0; i < inputString.size(); i++) {
    if (inputString[i] == '.') {
      if (emptyField) {
        return false;
      }
      countNumbers++;
      currentNumber = 0;
      emptyField = true;
    }
    else {
      int digit = inputString[i] - '0';
      if (digit < 0 || digit > 9) {
        return false;
      }
      emptyField = false;
      currentNumber = currentNumber * 10 + digit;
      if (currentNumber > 255) {
        return false;
      }
    }
  }
  return countNumbers == 4;
}


private static int[] setUnion(int[] A, int[] B) {

        ArrayList<Integer> C = new ArrayList<>();
        int pos_b = 0;

        Arrays.sort(A);
        Arrays.sort(B);

        for (int pos_a = 0; pos_a < A.length; pos_a++) {
            while (pos_b < B.length && B[pos_b] < A[pos_a]) {
                C.add(B[pos_b]);
                pos_b++;
            }
            C.add(A[pos_a]);
            if (pos_b < B.length && A[pos_a] == B[pos_b]) {
                pos_b++;
            }
        }
        while (pos_b < B.length) {
            C.add(B[pos_b]);
            pos_b++;
        }

        int[] res = new int[C.size()];
        for (int i = 0; i < res.length; i++) {
            res[i] = C.get(i);
        }

        return res;
    }


 static int chartFix(int[] chart)
        {
            int[] DP = new int[chart.Length];
            int maxLength = 1;
            DP[0] = 1;

            for (int i = 1; i < chart.Length; i++)
            {
                DP[i] = 1;

                for (int j = i - 1; j >= 0; j--)
                    if (DP[j] + 1 > DP[i] && chart[j] < chart[i])
                    {
                        DP[i] = DP[j] + 1;
                    }

                if (DP[i] > maxLength)
                {
                    maxLength = DP[i];
                }
            }

            return chart.Length - maxLength;
        }

bool areEquallyStrong(int yl, int yr, int fl, int fr) {
    return new HashSet<int>(){yl,yr}.SetEquals(new HashSet<int>(){fl,fr});
}


int sequenceElement(int[] a, int n) {
    var s = new Dictionary<int, int>();
    for(int i=0; i<4686; i++)
        s[i] = i<5 ?  a[i] : (s[i-1] + s[i-2] + s[i-3] + s[i-4] + s[i-5]) % 10;
    return s[n%4686];
}



typedef std::vector<std::vector<int>> matrix;
std::vector<int> easyAssignmentProblem(matrix skills) {
  return skills[0][0] + skills[1][1] > skills[0][1] + skills[1][0] ?
        std::vector<int>({1,2}) : std::vector<int>({2, 1});
}



int minimalNumberOfCoins(std::vector<int> coins, int price) {

  int result = 0;

  for (int i = (int)coins.size() - 1; i >= 0; i--) {
    result += price / coins[i];
    price %= coins[i];
  }

  if (price) {
    return -1;
  }
  return result;
}


long[] removeDigits(long n, int k) {
    var a = new List <long>();
    var s = n.ToString();
    for (int i=0; i<s.Length-k+1; i++)
        a.Add(long.Parse(s.Substring(i,k)));
    return new long[]{a.Min(), a.Max()};
}

function bfsComponentSize(matrix) {
 var visited = [],
    queue = [],
    componentSize = 0;
  for (var i = 0; i < matrix.length; i++) {
    visited.push(false);
  }
  visited[1] = true;
  queue.push(1);
  while (queue.length) {
    var currentVertex = queue.shift();
    visited[currentVertex] = true;
    componentSize++;
    for (var nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
      if (matrix[currentVertex][nextVertex] && !visited[nextVertex]) {
        visited[nextVertex] = true;
        queue.push(nextVertex);
      }
    }
  }
  return componentSize;
}



int numberOfSolutions(int n) {

  int result = 0;
  for (int a = n + 1; a < 2 * n; a++) {
    if ((a * n) % (a - n) == 0) {
      result++;
    }
  }

  return result * 2 + 1;
}



string capitalizeVowelsRegExp(string input) {
string s = "";
            for (int i = 0; i < input.Length; i++)
            {
                if ("aeiouy".Contains(input[i]))
                {
                    if (char.IsLower(input[i]))
                    {
                        s += char.ToUpper(input[i]);
                    }
                }
                else
                {
                    s += input[i];
                }
            }
            return s;
}



  int differentSubstrings(string inputString)
        {
            HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i < inputString.Length; i++)
            {
                for (int j = i; j < inputString.Length; j++)
                {
                    hash.Add(inputString.Substring(i, j - i + 1));
                }

            }
            return hash.Count;
        }


int[] threeAndFour(int n) {
	    List<int> ans = new List<int>();
            for (int i = 0; i < n; i++)
            {
                if (i % 3 == 0 && i % 4 == 0)
                {
                    ans.Add(i);
                }
            }
            return ans.ToArray();
}



int sumBelowBound(int bound) {
 int sum = 0;
            for (int i = 1; ; i++)
            {
                if (sum + i > bound) return i-1;
                
                    sum += i;

            }
}


string[] sortByLength(string[] inputArray) {
	    for (int i = 1; i < inputArray.Length; i++)
            {
                int indice = i;
                while (indice > 0 && inputArray[indice - 1].Length > inputArray[indice].Length)
                {
                    string temp = inputArray[indice - 1];
                    inputArray[indice - 1] = inputArray[indice];
                    inputArray[indice] = temp;
                    indice--;
                }
            }
            return inputArray;
}


int divisorsSubset(int[] subset, int n) {
	int c = 0;
        for (int i = 1; i <= n; i++) {
            bool ch = true;
            foreach (int aSubset in subset) {
                if (i % aSubset != 0)
                    ch = false;
            }
            if (ch) c++;
        }
        return c;
}


int[] theJanitor(string word) {
	    int[] ans = new int[26];
            int i = 0;
            for (char ch = 'a'; ch <= 'z'; ch++)
            {


                int last = word.LastIndexOf(ch);
                int first = word.IndexOf(ch);
                int dist = 0;
                if (last != -1) dist = last - first + 1;
                    
                ans[i++] = dist;

            }
            return ans;
}

char fractionComparison(int[] a, int[] b) {
    double da = (double)a[0] / (double)a[1];
            double db = (double)b[0] / (double)b[1];

            if (da == db)
            {
                return '=';
            }
            if (da > db) return '>';
            return '<';
}

int maxZeros(int n) {
	int answer = 0,
                maxZeros = 0;
        for (int k = 2; k <= n; k++) {
            int numZeros = 0,
                    value = n;
            while (value != 0) {
                if (value % k == 0) {
                    numZeros++;
                }
                value /= k;
            }
            if (numZeros > maxZeros) {
                maxZeros = numZeros;
                answer = k;
            }
        }
        return answer;
}



    static int[][] neighboringCells(int[][] matrix)
        {
            int[][] ans = new int[matrix.Length][];
            for (int i = 0; i < matrix.Length; i++)
            {
                ans[i] = new int[matrix[i].Length];
            }

            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (i - 1 >= 0) ans[i][j]++;
                    if (i + 1 < matrix.Length) ans[i][j]++;
                    if (j - 1 >= 0) ans[i][j]++;
                    if (j + 1 < matrix[i].Length) ans[i][j]++;
                }
            }
            return ans;

        }



   int differentValuesInMultiplicationTable2(int n, int m)
        {
            HashSet<int> hash = new HashSet<int>();
            for (int i = 1; i <= n; i++)
            {
                for (int j = 1; j <= m; j++)
                {
                    hash.Add(i * j);
                }

            }
            return hash.Count;
        }



int arrayMinimumAboveBound(int[] inputArray, int bound) {
     int dif = int.MaxValue;
            int ans = -1;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > bound)
                {
                    if (inputArray[i] - bound < dif)
                    {
                        dif = inputArray[i] - bound;
                        ans = inputArray[i];
                    }
                    //dif = inputArray[i] - bound;
                }
            }
            return ans;
}

static bool isLowerTriangularMatrix(int[][] matrix)
        {
            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = i; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] != 0)
                    {
                        return false;
                    }

                }
            }
            return true;
        }

bool isLowerTriangularMatrix(int[][] matrix) {
    for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = i +1; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] != 0)
                    {
                        return false;
                    }

                }
            }
            return true;
}


  static int[] extractMatrixColumn(int[][] matrix, int column)
        {
            int[] ans = new int[matrix.Length];
            for (int i = 0; i < matrix.Length; i++)
            {
                ans[i] = matrix[i][column];
            }
            return ans;
        }

------------------------

static bool esPalin(char[] ch)
        {
            int i = 0, j = ch.Length - 1;

            while (i < j)
            {
                if (ch[i] != ch[j]) return false;
                i++;
                j--;
            }
            return true;
        }

        static bool isOneSwapEnough(string inputString)
        {
            char[] ch = inputString.ToCharArray();
            if (esPalin(ch)) return true;
            for (int i = 0; i < ch.Length - 1; i++)
            {
                for (int j = i + 1; j < ch.Length; j++)
                {
                    char temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;
                    if (esPalin(ch)) return true;
                    temp = ch[j];
                    ch[j] = ch[i];
                    ch[i] = temp;
                }
            }
            return false;
        }



-----------------------------

bool isPermutation(int n, int[] inputArray) {
            bool[] cont = new bool[Math.Max( n + 1, inputArray.Max()+1)];

            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > 0)
                {
                    cont[inputArray[i]] = true;
                }
            }

            for (int i = 1; i <= n; i++)
            {
                if (cont[i] == false)
                {
                    return false;
                }
            }
            return true;
}


bool isPermutation(int n, int[] inputArray) {
      HashSet<int> hash = new HashSet<int>(inputArray);

            for (int i = 1; i <= n; i++)
            {
                if (!hash.Contains(i))
                {
                    return false;
                }
            }
            return true;
}


  int rightmostRoundNumber(int[] inputArray)
        {
            for (int i = inputArray.Length - 1; i >= 0; i--)
            {
                if (inputArray[i] % 10 == 0) return inputArray[i];
            }
            return -1;
        }


int deleteDigit(int n) {
int max = int.MinValue;
            string s = n.ToString();
            for (int i = 0; i < s.Length; i++)
            {
                max = Math.Max(max, int.Parse(s.Remove(i, 1)));
            }
            return max;
}

int cyclicString(string s) {
List<string> mismas = new List<string>();

            for (int i = 0; i < s.Length; i++)
            {
                string subs = "";
                for (int j = i + 1; j < s.Length; j++)
                {
                    if (s[i] == s[j])
                    {
                        subs = s.Substring(i, j - i );
                        //break;
                        mismas.Add(subs);
                    }
                }
            }

            foreach (string item in mismas)
            {
                string concat = "";
                for (int i = 0; concat.Length < s.Length; i++)
                {
                    concat += item;
                }
                if (concat.Contains(s))
                {
                    return item.Length;
                }
            }

            return s.Length;
}



        int countDistantPairs(string inputString, int distance)
        {
            int cont = 0;
            for (int i = 0; i + distance + 1 < inputString.Length; i++)
            {
                if (inputString[i] == inputString[i + distance + 1])
                {
                    cont++;
                }
            }
            return cont;

        }


std::string biggerWord(std::string w) {

  int leftSwap = -1;
  for (int i = (int)w.size() - 2; i >= 0; i--) {
    if (w[i] < w[i + 1]) {
      leftSwap = i;
      break;
    }
  }
  if (leftSwap == -1) {
    return "no answer";
  }

  int rightSwap = (int)w.size() - 1;
  while (w[leftSwap] >= w[rightSwap]) {
    rightSwap--;
  }
  std::swap(w[leftSwap++], w[rightSwap]);
  rightSwap = (int)w.size() - 1;
  while (leftSwap < rightSwap) {
    std::swap(w[leftSwap++], w[rightSwap--]);
  }
  return w;
}


    bool evenDigitsOnly(int n)
        {
            string impares = "13579";
            string s = n.ToString();

            for (int i = 0; i < s.Length; i++)
            {
                if (impares.Contains(s[i])) return false;
            }
            return true;
        }

 private static boolean noAdjacentBits(int a) {

        int lastBit = 0,
                idx = 0;
        while ((1 << idx) <= a) {
            int curBit = (a >> idx) & 1;
            if (lastBit == 1 && curBit == 1) {
                return false;
            }
            lastBit = curBit;
            idx++;
        }

        return true;
    }


bool passwordCheckRegExp(string inputString) {
    if (inputString.Length >= 5)
            {
                bool capital = false;
                bool small = false;
                bool digit = false;

                for (int i = 0; i < inputString.Length; i++)
                {
                    if (char.IsUpper(inputString[i]))
                    {
                        capital = true;
                    }
                    if (char.IsLower(inputString[i]))
                    {
                        small = true;
                    }
                    if (char.IsDigit(inputString[i]))
                    {
                        digit = true;
                    }
                }

                return capital && small && digit;
            }
            return false;
}


static string angleType(int measure)
        {
            if (measure < 90)
            {
                return "acute";
            }
            else if (measure == 90)
            {
                return "right";
            }
            else if (measure < 180)
            {
                return "obtuse";
            }

            return "straight";

        }

int[] quickSort(int[] a, int l, int r) {

  if (l >= r) {
    return a;
  }

  int x = a[l];
  int i = l;
  int j = r;

  while (i <= j) {
    while(a[i] < x) {
      i++;
    }
    while (a[j] > x) {
      j--;
    }
    if (i <= j) {
      int t = a[i];
      a[i] = a[j];
      a[j] = t;
      i++;
      j--;
    }
  }

  quickSort(a, l, j);
  quickSort(a, i, r);

  return a;
}


static int fibonacciIndex(int n)
        {

            if (n == 1) return 0;

            List<int> fib = new List<int>();
            fib.Add(0);
            fib.Add(1);

            int len = 1;
            int i = 2;
            for ( ; ; i++)
            {
                fib.Add(fib[i - 1] + fib[i - 2]);
                len = fib[i].ToString().Length;
                if (len == n) break;
            }
            return i;

        }


int largestFullBinaryTree(std::vector<int> parent) {

  struct Graph {
    std::vector<std::vector<int>> edges;
    int maxBinTree;

    Graph(std::vector<int> const & parent) {
      maxBinTree = 1;
      edges = std::vector<std::vector<int>>(parent.size());
      for (int i = 1; i < parent.size(); i++) {
        edges[parent[i]].push_back(i);
      }
    }

    int dfs(int v) {
      int firstMax = -1;
      int secondMax = -1;
      for (int u : edges[v]) {
        int curMax = dfs(u);
        if (curMax > firstMax) {
          secondMax = firstMax;
          firstMax = curMax;
        } else if (curMax > secondMax) {
          secondMax = curMax;
        }
      }
      if(secondMax==-1) return 1;
      int result = 1 + firstMax + secondMax;
      if (result > maxBinTree) {
        maxBinTree = result;
      }
      return result;
    }
  };

  Graph g(parent);
  g.dfs(0);
  return g.maxBinTree;
}


bool isPower(int n) {
if(n==1)
        return true;
    for(int index=2;index<=Math.Sqrt(n);index++) {
        for(int power=2;power<=Math.Sqrt(n);power++) {
            if(Math.Pow(index,power)==n)
                return true;
        }
    }
    return false;
}

  static string getMonthName(int mo)
        {
            if (mo < 1 || mo > 12) return "invalid month";
            string[] meses = { "Jan", "Feb",   "Mar",  "Apr",   "May",  "Jun",   "Jul", "Aug",  "Sep",  "Oct",
                              "Nov",  "Dec"  };

            return meses[mo - 1];
        }



        static int[] digitDifferenceSort(int[] a)
        {
            int[] difs = new int[a.Length];
            for (int i = 0; i < a.Length; i++)
            {
                int min = 10;
                int max = -1;

                int copia = a[i];
                while (copia > 0)
                {
                    min = Math.Min(min, copia % 10);
                    max = Math.Max(max, copia % 10);
                    copia /= 10;
                }
                int dif = max - min;
                difs[i] = dif;
            }

            for (int i = 0; i < a.Length - 1; i++)
            {
                for (int j = i + 1; j < a.Length; j++)
                {
                    if (difs[i] > difs[j])
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;

                        int temp_difs = difs[i];
                        difs[i] = difs[j];
                        difs[j] = temp_difs;
                    }
                    else if (difs[i] == difs[j])
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;

                        int temp_difs = difs[i];
                        difs[i] = difs[j];
                        difs[j] = temp_difs;

                    }
                }

            }
            return a;
        }




int differentDigitsNumberSearch(int[] inputArray) {
	    for (int i = 0; i < inputArray.Length; i++)
            {
                int copia = inputArray[i];
                HashSet<int> digs = new HashSet<int>();
                while (copia > 0)
                {
                    if (!digs.Add(copia % 10))
                    {
                        break;
                    }
                    copia /= 10;
                }
                if (copia ==0 ) return inputArray[i];

            }
            return -1;
}


int createAnagram(string s, string t) {
	    int[] hash_s = new int[26];
            int[] hash_t = new int[26];

            for (int i = 0; i < s.Length; i++)
            {
                hash_s[s[i] - 'A']++;
            }

            for (int i = 0; i < t.Length; i++)
            {
                hash_t[t[i] - 'A']++;
            }

            int comun = 0;
            for (int i = 0; i < 26; i++)
            {
                comun += Math.Min(hash_s[i], hash_t[i]);

            }
            return s.Length - comun;
}


int firstMultiple2(int[] divisors, int start) {
      for (int i = start; ; i++)
            {
                int j = 0;
                for (; j < divisors.Length ; j++)
                {
                    if (i % divisors[j] == 0) return i;
                }

            }
            return -1;
}


   int firstMultiple(int[] divisors, int start)
        {
            for (int i = start; ; i++)
            {
                int j = 0;
                for (; j < divisors.Length ; j++)
                {
                    if (i % divisors[j] != 0) break;
                }
                if (j == divisors.Length) return i;
            }
        }

  static  string formatString(string input)
        {

            string[] a = input.Split(' ');

            string s = "";
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i].Length > 0)
                {
                    s += a[i] + " ";
                }
            }
            return s.Trim();

        }


static int makeArrayConsecutive2(int[] statues)
        {
            int min = statues.Min();
            int max = statues.Max();

            HashSet<int> hash = new HashSet<int>(statues);

            List<int> ans = new List<int>();
            for (int i = min; i <= max; i++)
            {
                if (!hash.Contains(i))
                {
                    ans.Add(i);
                }
            }

            return ans.Count;
        }

int SumDig(int n)
        {
            int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
        }

     int[] digitalSumSort(int[] a)
        {
            int[] sd = new int[a.Length];
            for (int i = 0; i < a.Length; i++)
            {
                sd[i] = SumDig(a[i]);
            }

            for (int i = 0; i < a.Length - 1; i++)
            {
                for (int j = i + 1; j < a.Length; j++)
                {
                    int s_i = SumDig(a[i]);
                    int s_j = SumDig(a[j]);
                    if ( s_i > s_j)
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                    }
                    else if (s_i == s_j)
                    {
                        if (a[i] > a[j])
                        {
                            int temp = a[i];
                            a[i] = a[j];
                            a[j] = temp;
                        }
                    }
                }
            }
            return a;
        }



int differentValuesInMultiplicationTable(int n, int m)
        {

            HashSet<int> hash = new HashSet<int>();

            for (int i = 1; i <= n; i++)
            {
                for (int j = 1; j <= m; j++)
                {
                    hash.Add(i * j);
                }

            }
            return hash.Count;


        }



        bool isCorrectSentence(string inputString)
        {
            return char.IsLetter(inputString[0]) && char.IsLetter(inputString[inputString.Length - 1]);
        }

	bool isCorrectSentence(string inputString) {
 		return char.IsUpper(inputString[0]) &&  inputString[inputString.Length - 1] =='.';
	}

int depositProfit(int deposit, int rate, int threshold) {
 double sum = 0.0;
            sum = deposit + (deposit * rate/100.0);
            int i =1; 
            for (; ; i++)
            {
                if (sum >= threshold) break;
                sum = sum + (sum * rate / 100.0);

            }

            return i;
}


bool regularBracketSequence1(string sequence) {
   Stack<char> pila = new Stack<char>();

            for (int i = 0; i < sequence.Length; i++)
            {
                if (sequence[i] == '(')
                {
                    pila.Push(sequence[i]);
                }
                else
                {
                    if (pila.Count == 0) return false;

                    pila.Pop();
                }

            }
            return pila.Count == 0;
}



 int[] extractEachKth(int[] inputArray, int k)
        {
            List<int> ans = new List<int>();

            for (int i = 0; i < inputArray.Length; i++)
            {
                if ((i + 1) % k == 0)
                {
                    ans.Add(inputArray[i]);
                }

            }
            return ans.ToArray();
        }

HashSet<int> primeFactors(int n)
        {
            HashSet<int> pf = new HashSet<int>();
            // Print the number of 2s that divide n 
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                pf.Add(2);
                n /= 2;
            }

            // n must be odd at this point. So we can 
            // skip one element (Note i = i +2) 
            for (int i = 3; i <= Math.Sqrt(n); i += 2)
            {
                // While i divides n, print i and divide n 
                while (n % i == 0)
                {
                    //Console.Write(i + " ");
                    pf.Add(i);
                    n /= i;
                }
            }

            // This condition is to handle the case whien 
            // n is a prime number greater than 2 
            if (n > 2)
            {
              //   Console.Write(n);
                pf.Add(n);
            }

            return pf;
        } 

        int greatestCommonPrimeDivisor(int a, int b)
        {

            List<int> pfa = primeFactors(a).ToList();
            //pfa.Reverse();
            HashSet<int> pfb = primeFactors(b);

            for (int i = pfa.Count - 1; i >= 0; i--)
            {
                if (pfb.Contains(pfa[i])) return pfa[i];
            }
            return -1;
        }


   bool isArithmeticProgression(int[] sequence)
        {

            int dif = sequence[1] - sequence[0];

            for (int i = 1; i < sequence.Length; i++)
            {
                if (sequence[i] - sequence[i - 1] != dif)
                {
                    return false;
                }
            }
            return true;
        }

        int swapNeighbouringDigits(int n)
        {
            string s = n + "";
            char[] ch = s.ToCharArray();
            for (int i = 0; i + 1 < s.Length; i+=2)
            {
                char temp = ch[i];
                ch[i] = ch[i + 1];
                ch[i + 1] = temp;
            }
            return int.Parse(new string(ch));
        }




        bool isPangram(string sentence)
        {
            sentence = sentence.ToLower();
            for (char ch = 'a'; ch <= 'z'; ch++)
            {
                //car.Add(ch);
                if (!sentence.Contains(ch)) return false;
            }
            return true;


        }


int swapNeighbouringDigits(int n) {
string s = n + "";
            char[] ch = s.ToCharArray();
            for (int i = 0; i + 1 < s.Length; i+=2)
            {
                char temp = ch[i];
                ch[i] = ch[i + 1];
                ch[i + 1] = temp;
            }
            return int.Parse(new string(ch));
}


int numberOfTriangles2(int[] sticks) {
  int cont = 0;
            for (int i = 0; i < sticks.Length; i++)
            {
                for (int j = i + 1; j < sticks.Length; j++)
                {
                    for (int k = j + 1; k < sticks.Length; k++)
                    {
                        if (sticks[i] + sticks[j] > sticks[k])
                        {
                            cont++;
                        }

                    }
                }

            }
            return cont;
}



double[] quadraticEquation(int a, int b, int c) {
int discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            ArrayList<Double> empty = new ArrayList<>();
            return empty;
        }
        if (discriminant == 0) {
            ArrayList<Double> answer = new ArrayList<>();
            answer.add(-b / (2.0 * a));
            return answer;
        }
        ArrayList<Double> roots = new ArrayList<>();
        roots.add((-b - Math.sqrt(discriminant)) / (2.0 * a));
        roots.add((-b + Math.sqrt(discriminant)) / (2.0 * a));
        if (roots.get(0) > roots.get(1)) {
            double tmp = roots.get(1);
            roots.set(1, roots.get(0));
            roots.set(0, tmp);
        }
        return roots;
}

int differentValues(int[] a, int d) {
 int cerca_min = int.MaxValue;
            int min_dif = -1;
            for (int i = 0; i < a.Length; i++)
            {

                for (int j = i + 1; j < a.Length; j++)
                {
                    int dif = Math.Abs(a[i] - a[j]);

                    if (dif <= d)
                    {
                        int cerca_local = d - dif;

                        if (cerca_local < cerca_min)
                        {
                            cerca_min = cerca_local;
                            min_dif = dif; 
                        }
                       
                    }
                }
            }

            return min_dif;
}


string deleteWhitespaces(string inputStr)
        {
            string s = "";
            for (int i = 0; i < inputStr.Length; i++)
            {
                if (inputStr[i] != ' ') s += inputStr[i];
            }
            return s;
        }


        int digitSum(int n)
        {
            int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
        }



int[] maxSumSegments(int[] inputArray) {
    var result = new List<int>();
    var n = inputArray.Length;
    var store = new int[n];
    
    store[0] = inputArray[0];
    
    for (int i = 1; n > i; ++i) {
        store[i] = inputArray[i] + store[i - 1];
    }
    
    for (int i = 0; n > i; ++i) {
        result.Add(getMaxSumIndex(i, store));
    }
    
    return result.ToArray();
}

int getMaxSumIndex(int n, int[] sums) {
    var l = 0;
    var r = l + n;
    var result = 0;
    var sum = int.MinValue;
    
    while (sums.Length > r) {
        var temp = 0 == l ? (sums[r]) : (sums[r] - sums[l - 1]);
        
        if (sum < temp) {
            sum = temp;
            result = l;
        }
        
        ++l;
        ++r;
    }
    
    return result;
}


 static int firstNotDivisible(int[] divisors, int start)
        {

            for (int i = start; ; i++)
            {
                int j = 0;
                for ( ; j < divisors.Length; j++)
                {
                    if (i % divisors[j] == 0)
                    {
                        break;
                    }
                }
                if (j == divisors.Length)
                {
                    return i;
                }

            }
            
        }



int lrSegmentNumber(int l, int r) {
   string s = "";
            for (int i = l; i <= r; i++)
            {
                s += i + "";
            }
            return int.Parse(s);
}



int smallestUnusualNumber(string a) {
    if (a.IndexOf('0')>=0) return 0;
    int s=0;
    int p=1;
    for (int i=0; i<a.Length; i++){
        s=s+(a[i]-'0');
        p=p*(a[i]-'0');
        if (p>1000000) return 10-a[a.Length-1]+'0';
    }
    if (s>p) return 0;
    else return 10-a[a.Length-1]+'0';
}

string reversedSumOfDigits(int p, int n) {
    int m=n;
    if (n*9<p)return "-1";
    if (p==0&&n>1)return "-1";
    string r="";
    while (p>9){
        r+="9";
        p-=9;
        n--;
    }
    if (n>1) r=(p-1)+r;
    else return p+r;
    r=r.PadLeft(m-1,'0');
    return "1"+r;
}

bool isTournament(int n, int[] fromV, int[] toV) {
    var a = Enumerable.Range(1, n).ToDictionary(c => c, c=> new HashSet<int>(){c});
    
    for (int i = 0; i < fromV.Length; i++)
    {
        var f = fromV[i];
        var t = toV[i];
        
        if (!a[f].Add(t))
            return false;
        
        if (!a[t].Add(f))
            return false;
    }
    
    return a.All(kv => kv.Value.Count == n);
}


def combs(comb1, comb2):

    def getMask(comb):
        mask = 0
        for i in range(0, len(comb)):
            c = comb[i]
            mask = (mask << 1) + (c == '*')
        return mask

    m1 = getMask(comb1)
    m2 = getMask(comb2)
    len1 = len(comb1)
    len2 = len(comb2)
    answer = len1 + len2
    for i in range(-len1, len2 + 1):
        if i < 0:
            tmp = m2 << (-i) & m1
            length = max(-i + len2, len1)
        else:
            tmp = m1 << i & m2
            length = max(i + len1, len2)
        if tmp == 0 and answer > length:
            answer = length

    return answer


def pairOfShoes(shoes):
    leftShoes = []
    rightShoes = []
    for i in range(len(shoes)):
        if shoes[i][0] == 0:
            leftShoes.append(shoes[i][1])
        else:
            rightShoes.append(shoes[i][1])
    leftShoes.sort()
    rightShoes.sort()
    if len(leftShoes) != len(rightShoes):
        return False
    for i in range(len(leftShoes)):
        if leftShoes[i] != rightShoes[i]:
            return False
    return True


int[] maximalAllowableSubarrays(int[] inputArray, int maxSum) {
	    List<int> lista = new List<int>();
            for (int i = 0; i < inputArray.Length; i++)
            {
                int sum = 0;
                
                int j = i;
                while (j < inputArray.Length && sum + inputArray[j] <= maxSum)
                {
                    //break;
                    //if (j >= inputArray.Length) break;
                    sum += inputArray[j];
                    j++;
                }

                lista.Add(j-1);
            }

            return lista.ToArray();
}

int arrayMaximalAdjacentDifference(int[] inputArray) {
    int max_dif = 0;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                max_dif = Math.Max(max_dif, Math.Abs(inputArray[i] - inputArray[i + 1]));
            }
            return max_dif;
}


int[][] reverseOnDiagonals(int[][] matrix) {
 for (int i = 0; i < matrix.Length / 2; i++)
            {
                //int temp = matrix[i][matrix.Length - i - 1];
                //matrix[i][matrix.Length - i - 1] = matrix[i][i];
                //matrix[i][i] = temp;

                int temp2 = matrix[i][matrix.Length - i - 1];
                matrix[i][matrix.Length - i - 1] = matrix[matrix.Length - i - 1][i];
                matrix[matrix.Length - i - 1][i] = temp2;

                int temp = matrix[i][i];
                matrix[i][i] = matrix[matrix.Length - i - 1][matrix.Length - i - 1];
                matrix[matrix.Length - i - 1][matrix.Length - i - 1] = temp;

                

            }
            return matrix;
}


boolean subsetsSequence(int[][] sets) {

  class Helper {
    boolean isSubset(int[] setA, int[] setB) {
      int j = 0;
      for (int i = 0; i < setB.length; i++) {
        if (j < setA.length && setA[j] == setB[i]) {
          j++;
        }
      }
      if (j == setA.length) {
        return true;
      }
      else {
        return false;
      }
    }
  };

  Helper h = new Helper();

  int[] supersets = new int[sets.length];

  for (int i = 0; i < sets.length; i++) {
    Arrays.sort(sets[i]);
  }

  for (int i = 0; i < sets.length; i++) {
    for (int j = i + 1; j < sets.length; j++) {
      if (h.isSubset(sets[i], sets[j])) {
                    supersets[i]++;
                }
      if (h.isSubset(sets[j], sets[i])) {
        supersets[j]++;
      }
    }
  }

  Arrays.sort(supersets);

  for (int i = 0; i < sets.length; i++) {
    if (supersets[i] < i) {
      return false;
    }
  }

  return true;
}


public bool RobotWalk(int[] a){

       int minX = 0;
        int minY = -1;
        int maxX = int.MaxValue;
        int maxY = int.MaxValue;

        int x = 0;
        int y = 0;

        for (int i = 0; i < a.Length; i++) {
            switch (i % 4) {

                case 0:
                    y += a[i];
                    if (y >= maxY) {
                        return true;
                    }
                    maxY = y;
                    break;

                case 1:
                    x += a[i];
                    if (x >= maxX) {
                        return true;
                    }
                    maxX = x;
                    break;

                case 2:
                    y -= a[i];
                    if (y <= minY) {
                        return true;
                    }
                    minY = y;
                    break;

                case 3:
                    x -= a[i];
                    if (x <= minX) {
                        return true;
                    }
                    minX = x;
                    break;
            }
        }

        return false;
    
}


 
 bool isArithmeticProgression(int[] sequence)
        {
            int dif = sequence[1] - sequence[0];

            for (int i = 1; i < sequence.Length; i++)
            {
                if (sequence[i] - sequence[i - 1] != dif) return false;

            }
            return true;
        }


int countIncreasingSequences(int n, int k) {

  /*
   * vector dp (short for dynamic programming)
   * is used for storing the interim values.
   */
  std::vector<int> line(k + 1, 0);
  std::vector<std::vector<int>> dp(n + 1, line);
  dp[0][0] = 1;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      for (int q = 0; q < j; q++) {
        dp[i][j] += dp[i - 1][q];
      }
    }
  }

  int sum = 0;
  for (int j = 1; j <= k; j++) {
    sum += dp[n][j];
  }

  return sum;
}


int nearestRoundNumber(int value) {
     while (value % 10 != 0)
            {
                value++;
            }

            return value;
}



int countWaysToChangeDigit(int value) {
int answer = 0;
        while (value > 0) {
            answer += 9 - value % 10;
            value /= 10;
        }
        return answer;
}

bool isSkewSymmetricMatrix(std::vector<std::vector<int>> matrix) {
for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix.size(); j++) {
            if (matrix[i][j] + matrix[j][i] != 0) {
                return false;
            }
        }
    }
    return true;
}

static int commonCharacterCount(string s1, string s2)
        {
            char[] ch_s1 = new char[26];
            char[] ch_s2 = new char[26];

            for (int i = 0; i < s1.Length; i++)
            {
                ch_s1[s1[i] - 'a']++;
            }
            for (int i = 0; i < s2.Length; i++)
            {
                ch_s2[s2[i] - 'a']++;
            }

            int ans = 0;
            for (int i = 0; i < 26; i++)
            {

                ans += Math.Min(ch_s1[i] , ch_s2[i]);
            }
            return ans;

        }


        bool checkSameElementExistence(int[] arr1, int[] arr2)
        {
            HashSet<int> hash = new HashSet<int>(arr2);

            for (int i = 0; i < arr1.Length; i++)
            {
                if (hash.Contains(arr1[i])) return true;
            }

            return false;
        }



function numberOfTriangles2(sticks) {
var ans = 0;
  for (var i = 0; i < sticks.length - 2; i++) {
    for (var j = i + 1; j < sticks.length - 1; j++) {
      var mx = sticks[i] + sticks[j];
      var l = j,
          r = sticks.length ;
      while (r - l > 1) {
        var m = Math.floor((l + r) / 2);
        if (sticks[m] >= mx) {
          r = m;
        } else {
          l = m;
        }
      }
      ans += r - j - 1;
    }
  }

  return ans;
}


static  string insertDashes(string inputString)
        {
            string[] espacios = inputString.Split(' ');

            for (int i = 0; i < espacios.Length; i++)
            {
                string linea = "";
                for (int j = 0; j < espacios[i].Length; j++)
                {
                    linea += espacios[i][j] + "-";
                }
                linea = linea.TrimEnd('-');
                espacios[i] = linea;
            }

            string ans = "";
            for (int i = 0; i < espacios.Length; i++)
            {
                ans += espacios[i] + " ";
            }
            return ans.TrimEnd(' ') ;
        }

        bool isCaseInsensitivePalindrome(string inputString)
        {

            inputString = inputString.ToLower();
            int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] != inputString[j])
                {
                    return false;
                }

                i++;
                j--;
            }
            return true;
        }


bool checkEqualFrequency(std::vector<int> inputArray) {

  int numberOfEqual = 1;

  std::sort(inputArray.begin(), inputArray.end());

  while (numberOfEqual < inputArray.size()
      && inputArray[numberOfEqual - 1] == inputArray[numberOfEqual]) {
    numberOfEqual++;
  }

  if (inputArray.size() % numberOfEqual != 0) {
    return false;
  }

  for (int i = 0; i < inputArray.size(); i += numberOfEqual) {
    if (i && inputArray[i] == inputArray[i - 1]) {
      return false;
    }
    for (int j = i + 1; j < i + numberOfEqual; j++) {
      if (inputArray[j] != inputArray[j - 1]) {
        return false;
      }
    }
  }

  return true;
}




string insertDashes(string inputString) {
string[] espacios = inputString.Split(' ');

            for (int i = 0; i < espacios.Length; i++)
            {
                string linea = "";
                for (int j = 0; j < espacios[i].Length; j++)
                {
                    linea += espacios[i][j] + "-";
                }
                linea = linea.TrimEnd('-');
                espacios[i] = linea;
            }

            string ans = "";
            for (int i = 0; i < espacios.Length; i++)
            {
                ans += espacios[i] + " ";
            }
            return ans.TrimEnd(' ') ;
}



int arithmeticProgression(int element1, int element2, int n) {
     int cont = 1;
            int i = element1;
            int dif = element2 - element1;
            for ( ; cont < n; i += dif)
            {
                //i += element2 - element1;
               // lista.Add(i);
                cont++;
                //Console.WriteLine(i);
            }

            return i;
}



 int gcd(int a, int b)
        {
            if (a == 0)
                return b;
            return gcd(b % a, a);
        } 


        int eulersTotientFunction(int n)
        {
            int result = 1;
            for (int i = 2; i < n; i++)
                if (gcd(i, n) == 1)
                    result++;
            return result;
        }




int sumOfCubes(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i * i;
            }
            return sum;
        }

        char firstDigit(string inputString)
        {
            for (int i = 0; i < inputString.Length; i++)
            {
                if (char.IsDigit(inputString[i]))
                {
                    return inputString[i];
                }

            }
            return '0';
        }


       static  bool isSumOfConsecutive(int n)
        {
            int sum = 0;
            for (int i = 1; i < n; i++)
            {
                sum = 0;
                for (int j = i; ; j++)
                {
                    if (sum > n) break;
                    if (sum == n) return true;
                    sum += j;
                }

            }
            return false;
        }


bool isSumOfConsecutive(int n) {
    int sum = 0;
            for (int i = 1; i < n; i++)
            {
                sum = 0;
                for (int j = i; ; j++)
                {
                    if (sum > n) break;
                    if (sum == n) return true;
                    sum += j;
                }

            }
            return false;
}


 static string integerToStringOfFixedWidth(int number, int width)
        {

            string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;

        }

 int sumOfCubes(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i * i;
            }
            return sum;
        }

        char firstDigit(string inputString)
        {
            for (int i = 0; i < inputString.Length; i++)
            {
                if (char.IsDigit(inputString[i]))
                {
                    return inputString[i];
                }

            }
            return '0';
        }

        static string integerToStringOfFixedWidth(int number, int width)
        {

            string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;

        }

 
string integerToStringOfFixedWidth(int number, int width) {
    string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;
}

private static int knapsackLight(int value1, int weight1,
                                     int value2, int weight2, int maxW) {

        if (weight1 + weight2 <= maxW) {
            return value1 + value2;
        }
        if (Math.min(weight1, weight2) > maxW) {
            return 0;
        }
        if (weight1 <= maxW && (value1 >= value2 || weight2 > maxW)) {
            return value1;
        }
        return value2;
    }


int commonPoints(int l1, int r1, int l2, int r2) {
   int result = Math.min(r1, r2) - Math.max(l1, l2) - 1;
        if (result < 0) {
            result = 0;
        }
        return result;
}



bool isInfiniteProcess(int a, int b) {
      if(b>=a && (b-a)%2==0) {
            return false;
        }
        
        return true;
        
}


bool isInformationConsistent(std::vector<std::vector<int>> evidences) {
    for (int i{}; i < evidences[0].size(); ++i) {
        int neg{},
            pos{};
        for (int j{}; j < evidences.size(); ++j) {
            neg += evidences[j][i] < 0;
            pos += evidences[j][i] > 0;
        }

        if (neg && pos)
            return 0;
    }

    return true;
} 


std::string knapsackLight2(int a, int b, int c) {
    if (a + b <= c)
        return "both";
    if (a <= c && b <= c)
        return "either";
    if (a <= c)
        return "first";
    if (b <= c)
        return "second";
    return "none";
}

def parkingCost(timeIn, timeOut):
    diff = (int(timeOut[:2]) * 60 +
        int(timeOut[3:]) -
        int(timeIn[:2]) * 60 -
        int(timeIn[3:]))
    if diff <= 30:
        return 0
    if diff <= 120:
        return (diff - 21) // 10
    return 9 + ((diff - 111) // 10) * 2

-----------------------
int CargarFilaArriba(int num, int en_fila, int[][] m, int col_izq, int col_der)
    {
        for (int i = col_izq; i <= col_der; i++)
        {
            m[en_fila][i] = num++;
        }
        return num;
    }

     int CargarFilaAbajo(int num, int en_fila, int[][] m, int col_izq, int col_der)
    {
        for(int i = col_der; i>= col_izq; i--)
        {
            m[en_fila][i] = num++;
        }
        return num;
    }

     int CargarColDer(int num, int en_col, int[][] m, int fila_arriba, int fila_abajo)
    {
        for (int i = fila_arriba; i <= fila_abajo; i++)
        {
            m[i][en_col] = num++;
        }

        return num;
    }

     int CargarColIzq(int num, int en_col, int[][] m, int fila_arriba, int fila_abajo)
    {
        for (int i = fila_abajo; i >= fila_arriba; i--)
        {
            m[i][en_col] = num++;
        }
        return num;
    }



     int[][] spiralNumbers(int n)
    {
        int i = 0;
        int j = n;
        int[][] matriz = new int[n][];

        for (i = 0; i < n; i++)
        {
            matriz[i] = new int[n];
        }

        int num = 1;

        int fila_arriba = 0, fila_abajo = n - 1;
        int col_izq = 0, col_der = n - 1;

        while (fila_arriba <= fila_abajo &&
            col_izq <= col_der)
        {
            num = CargarFilaArriba(num, fila_arriba, matriz, col_izq, col_der);
            fila_arriba++;
            num = CargarColDer(num, col_der, matriz, fila_arriba, fila_abajo);
            col_der--;
            num = CargarFilaAbajo(num, fila_abajo, matriz, col_izq, col_der);
            fila_abajo--;
            num = CargarColIzq(num, col_izq, matriz, fila_arriba, fila_abajo);
            col_izq++;
        }

        return matriz;
    }

---------------------------

def cipher26(message):
    def dig(x):
        return ord(x)-97
    def let(x):
        return chr(x+97)
    
    s = 0
    ans = ''
    for x in message:
        ans += let( (dig(x) - s)%26 )
        s = dig(x)
    return ans



int parabole(int a, int b, int c, int x) {
  return   (int) (a * Math.pow(x, 2) + b * x + c);
}



bool arithmeticExpression(int a, int b, int c)
        {
            double x = (double)a;
            double y = (double)b;
            double z = (double)c;
            return x + y == z || x - y == z || x / y == z || x * y == z;
        }

        bool checkFactorial(int n)
        {
            int prod = 1;
            for (int i = 1;prod <=n ; i++)
            {
                prod *= i;
                if (prod == n) return true;

            }
            return false;
        }


      function centuryFromYear(year) {
    var newYear = year.toString().length;
    var stYear
    if (newYear >= 4){
        stYear = year.toString().substring(0, 2);
        if (year % 100 !== 0){ 
        return (parseInt(stYear)+1);
        } else {
        return parseInt(stYear);  
        };
    } else if (newYear >= 3){
        stYear = year.toString().substring(0,1);
        if (year % 100 !== 0){ 
        return (parseInt(stYear)+1);
        } else {
        return parseInt(stYear);  
        };
    } else if (newYear < 3){
        return 1;
    };
};



int centuryFromYear(int year) {
    for (int i = 1; ; i++)
            {
                if (year >= i && year <= i * 100)
                {
                    return i;
                }

            }
}
   

int digitDistanceNumber(int n)
        {
            string s = n.ToString();

            string concat = "";
            for (int i = 0; i + 1 < s.Length; i++)
            {
                concat +=  Math.Abs( (s[i] - '0') - (s[i + 1] - '0'));
            }
            return int.Parse(concat);
        }

  string reflectString(string inputString)
        {
            string ans = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                ans +=  (char)( 'a' - inputString[i] + 'z');
            }
            return ans;
        }



string reflectString(string inputString) {
     string ans = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                ans +=  (char)( 'a' - inputString[i] + 'z');
            }
            return ans;
}

bool robotWalk(std::vector<int> a) {
    int minX = 0;
    int minY = -1;
    int maxX = INT_MAX;
    int maxY = INT_MAX;

    int x = 0;
    int y = 0;

    for (int i = 0; i < a.size(); i++) {
        switch (i % 4) {

        case 0:
            y += a[i];
            if (y >= maxY) {
                return true;
            }
            maxY = y;
            break;

        case 1:
            x += a[i];
            if (x >= maxX) {
                return true;
            }
            maxX = x;
            break;

        case 2:
            y -= a[i];
            if (y <= minY) {
                return true;
            }
            minY = y;
            break;

        case 3:
            x -= a[i];
            if (x <= minX) {
                return true;
            }
            minX = x;
            break;
        }
    }

    return false;
} 


static int fibonacciNumber(int n)
        {

            List<int> fibs = new List<int>();
            fibs.Add(0);
            fibs.Add(1);
            for (int i = 2; i <= n; i++)
            {
                fibs.Add(fibs[i - 1] + fibs[i - 2]);
            }

            return fibs[n];
        }



   string replaceAllDigitsRegExp(string input)
        {
            for (char i = '0'; i <= '9'; i++)
            {
                input = input.Replace(i, '#');
            }
            return input;
        }

        static int calculationsWithCoins(int a, int b, int c)
        {
            HashSet<int> hash = new HashSet<int>();
            hash.Add(a);
            hash.Add(b);
            hash.Add(c);

            hash.Add(a +b );
            hash.Add(a +c);
            hash.Add(b+c);

            hash.Add(a+b+c);

            return hash.Count;

        }


        bool arithmeticExpression(int a, int b, int c)
        {
            if ((double)a + (double)b == (double)c) return true;
            if ((double)a - (double)b == (double)c) return true;
            if ((double)a / (double)b == (double)c) return true;
            if ((double)a * (double)b == (double)c) return true;
            return false;

        }



 string[] splitAddress(string address)
        {
            string[] s = address.Split(new string[] {"://",".", "/"}, StringSplitOptions.RemoveEmptyEntries);

            List<string> ans = new List<string>();
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] != "com") ans.Add(s[i]);
            }
            return ans.ToArray();

        }

        int sumOfDivisors(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += n % i == 0 ? i : 0;
            }
            return sum;
        }

        int telephoneGame(string[] messages)
        {
            string actual = messages[0];
            for (int i = 1; i < messages.Length; i++)
            {
                if (messages[i] != actual) return i;
            }
            return -1;
        }



   bool areIsomorphic(int[][] array1, int[][] array2)
        {

            if (array1.Length == array2.Length)
            {

                for (int i = 0; i < array1.Length; i++)
                {
                    if (array1[i].Length != array2[i].Length)
                    {
                        return false;
                    }
                     
                }
                return true;
            }
            return false;

        }

        int divisorsSubset(int[] subset, int n)
        {
            int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                int j = 0;
                for (; j < subset.Length; j++)
                {
                    if (i % subset[j] != 0) break;
                }
                if (j >= subset.Length)
                {
                    cont++;
                }
            }
            return cont;
        }



        string myConcat(string[] strings, string separator)
        {
            string s = "";

            for (int i = 0; i < strings.Length; i++)
            {
                s += strings[i] + separator;

            }
            return s;
        }



int[][] spiralNumbers(int n) {
  int[][] m = new int[n][n];
  int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  int currentDirectionIndex = 0;
  int currentRow = 0;
  int currentColumn = 0;
  int currentNum = 1;
  int tmpRow;
  int tmpColumn;
  for (int i = n*n; i > 0; i--) {
    m[currentRow][currentColumn] = currentNum;
    currentNum++;
    if (i > 1) {
      // Determine the next cell
      while (true) {
        tmpRow = currentRow + directions[currentDirectionIndex][0];
        tmpColumn = currentColumn + directions[currentDirectionIndex][1];
        if (tmpRow < 0 || tmpRow >= n ||
            tmpColumn < 0 || tmpColumn >= n ||
            m[tmpRow][tmpColumn] != 0) {
          currentDirectionIndex = (currentDirectionIndex + 1) % 4;
        } else {
          currentRow = tmpRow;
          currentColumn = tmpColumn;
          break;
        }
      }
    }
  }
  return m;
}




bool isMAC48Address(std::string inputString) {

  for (int i = 0; i < inputString.size(); i++) {
    if ( (i+1) %3 ==0) {
      if (inputString[i] != '-') {
        return false;
      }
    }
    else {
      char sym = inputString[i];
      if (!('0' <= sym && sym <= '9' || 'A' <= sym && sym <= 'F')) {
        return false;
      }
    }
  }

  return inputString.size() == 17;
}



double computeDefiniteIntegral(int l, int r, int[] p) {
 double result = 0;
        int lExp = l,
                rExp = r;

        for (int i = 0; i < p.length; i++) {
            result += p[i] * (double) (rExp - lExp) / (i + 1);
            lExp *= l;
            rExp *= r;
        }

        return result;
}

bool isLucky(int n) {
      int len = 0;
            int totalsum = 0;
            int copia = n;
            while (copia > 0)
            {
                len++;
                totalsum += copia % 10;
                copia /= 10;
            }

            int copia2 = n;
            int mitad = 0;
            int cont =0;
            while (cont < len/2)
            {
                int dig = copia2 % 10;
                mitad += dig;
                cont++;
                copia2 /=10;
            }

            return totalsum - mitad == mitad;
}


int appleBoxes(int k) {
	int sum =  (1 + k) * k / 2;
   	 return (k % 2 == 1) ? -sum : sum;
}


   static int[][] swapDiagonals(int[][] matrix)
        {

            for (int i = 0; i < matrix.Length; i++)
            {
                int temp = matrix[i][i];
                matrix[i][i] = matrix[i][matrix.Length - i - 1];
                matrix[i][matrix.Length - i - 1] = temp;
            }

            return matrix;
        }


   int gcm(int a, int b) {
        return b == 0 ? a : gcm(b, a % b);
    }

        int[] fractionSum(int[] A, int[] B) {
        int[] sum = new int[]{(A[0] * B[1]) + (B[0] * A[1]), (A[1] * B[1])};
        int gcm = gcm(sum[0], sum[1]);
        return new int[]{sum[0] / gcm, sum[1] / gcm};
    }




bool alphabetSubsequence(string s) {
for (int i = 0; i +1 < s.Length; i++)
            {
                if (s[i] >= s[i + 1]) return false;

            }
            return true;
}



boolean pointInLine(int[] point, int[] line) {
return line[0] * point[0] + line[1] * point[1] + line[2] == 0;
}


static int comfortableNumbers(int L, int R)
        {

            int total_pairs = 0;

            for (int i = L; i <= R; i++)
            {
                for (int j = i + 1; j <= R; j++)
                {
                    int s_a = 0; // digitSum(i);
                    int s_b = 0; // digitSum(j);

                    //int _sum = 0;
                    int c_i = i;
                    while (c_i > 0)
                    {
                        s_a += (c_i % 10);
                        c_i = c_i / 10;
                    }

                    int c_j = j;
                    while (c_j > 0)
                    {
                        s_b += (c_j % 10);
                        c_j = c_j / 10;
                    }

                    if (j >= (i - s_a) && j <= (i + s_a) &&
                          i >= (j - s_b) && i <= (j + s_b)
                       )
                    {
                        total_pairs++;
                    }
                }
            }
            return total_pairs;
        }


int[] primeFactors2(int n) {

            HashSet<int> hash = new HashSet<int>();
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                hash.Add(2);
                n /= 2;
            }

          
            for (int i = 3; i *i <= n; i += 2)
            {
                
                while (n % i == 0)
                {
                   
                    hash.Add(i);
                    n /= i;
                }
            }

           
            if (n > 2)
            {
        
                hash.Add(n);
            }
            return hash.ToArray();
}


string decipher(string cipher) {
	string result="";
    while(cipher.Length>0) {
        string s = cipher.Substring(0,2);
        int n = int.Parse(s);
        if(n>=97) {
            result+=(char)n;
            cipher = cipher.Substring(2);
        }else {
            s = cipher.Substring(0,3);
            n = int.Parse(s);
            result+=(char)n;
            cipher = cipher.Substring(3);
        }
    }
    return result;
}


int[] nextSecond(int[] currentTime)
        {
            currentTime[2]++;

            if (currentTime[2] > 59)
            {
                currentTime[2] = 0;
                currentTime[1]++;
                if (currentTime[1] > 59)
                {
                    currentTime[1] = 0;
                    currentTime[0]++;
                    if (currentTime[0] > 23)
                    {
                        currentTime[0] = 0;
                    }
                }
            }

            return currentTime;
        }



private static int combs(String comb1, String comb2) {

        class Helper {
            int getMask(String comb) {
                int mask = 0;
                for (int i = 0; i < comb.length(); i++) {
                    char c = comb.charAt(i);
                    mask = (mask << 1) + (c == '*' ? 1 : 0);
                }
                return mask;
            }
        }
        Helper h = new Helper();

        int m1 = h.getMask(comb1);
        int m2 = h.getMask(comb2);
        int len1 = comb1.length();
        int len2 = comb2.length();
        int answer = len1 + len2;
        for (int i = -len1; i <= len2; i++) {
            int tmp, length;
            if (i < 0) {
                tmp = m2 << (-i) & m1;
                length = Math.max(-i + len2, len1);
            } else {
                tmp = m1 << i & m2;
                length = Math.max(i + len1, len2);
            }
            if (tmp == 0 && answer > length) {
                answer = length;
            }
        }

        return answer;
    }


int crossingSum(int[][] matrix, int a, int b) {
    int sum = 0;
            for (int i = 0; i < matrix[0].Length; i++)
            {
                sum += matrix[a][i];
            }
            for (int i = 0; i < matrix.Length; i++)
            {
                sum += matrix[i][b];
            }
            sum -= matrix[a ][b ];
            return sum;
}


std::vector<int> prefixFunctionNaive(std::string s) {
std::vector<int> result;

    for (int i = 0; i < s.size(); i++) {
        result.push_back(0);
        //cout << "i=" << i << endl;
        for (result[i] = i; result[i] >= 0; result[i]--) {
            //cout << "result=" << result << endl;
            bool matches = true;
            for (int j = i - result[i] + 1; j <= i; j++) {
                //cout << "s[" << j << "]=" << s[j] << ", ";
                //cout << "s[" << j - i + result[i] - 1 << "]=" << s[j - i + result[i] - 1] << endl;
                if (s[j] != s[j - i + result[i] - 1]) {
                    matches = false;
                    break;
                }
            }
            if (matches) {
                break; // continue; -> break;
            }
        }
    }

    return result;
}


bool isLucky(int n) {

  std::vector<int> digits;
  int sum = 0;

  while (n > 0) {
    digits.push_back(n % 10);
    n /= 10;
  }

  for (int i = 0; i < digits.size(); i++) {
    if (i < digits.size() / 2) {
      sum += digits[i];
    }
    else {
      sum -= digits[i];
    }
  }

  if (sum) {
    return false;
  }
  return true;
}



def countWays(n, k):
    res=1
    for i in range (k):
        res = ((res*(n-i))//(i+1))
    return res%1000000007

int maximumSubsetProduct(std::vector<int> a) {
int mnn = -1111111111;
    int cnt = 0;
    for(int i=0;i<a.size();++i)
    {
        if(a[i] > 0)
            continue;
        mnn = max(mnn , a[i]);
        cnt++;
    }
    if(cnt % 2 == 0 || a.size() == 1)
        return 1;
    return mnn;
}

std::vector<int> powersOfTwo(int n) {

  std::vector<int> ans;
  int cur = 1;
  while (n > 0) {
    if (n % 2 == 0) {
      ans.push_back(cur);
    }
    n <<= 1;
    cur <<= 1;
  }

  return ans;
}

def binaryGenerator(s):
    a = set()
    a.add('')
    for i in range (len(s)):
        b = set()
        for c in a:
            b.add(c+"1")
            if s[i]=='0':
                b.add(c+"0")
        a=b
    r=list(a)
    r.sort()
    return r


static  bool isGeometricProgression(int[] sequence)
{
            bool flag1 = true ;
            bool flag2 = true ;
            double dif = (double)sequence[0] / (double)sequence[1];

            for (int i = 1; i  + 1< sequence.Length; i++)
            {
                if ((double)sequence[i] / (double)sequence[i + 1] != dif)
                   
                {
                      flag1 = false;
                      break;
                }

            }
            dif = (double)sequence[1] / (double)sequence[0];
            for (int i = 1; i + 1 < sequence.Length; i++)
            {
                if ((double)sequence[i + 1] / (double)sequence[i] != dif)
                    
                {
                    flag2 = false;
                    break;
                }

            }

            return flag1 || flag2;

}

static int growingPlant(int upSpeed, int downSpeed, int desiredHeight)
        {
            int sum = 0;
            int cont = 0;
            while (true)
            {
                sum += upSpeed;
                cont++;
                if (sum >= desiredHeight)
                {
                    break;
                }
                sum -= downSpeed;
            }
            return cont;
        }

